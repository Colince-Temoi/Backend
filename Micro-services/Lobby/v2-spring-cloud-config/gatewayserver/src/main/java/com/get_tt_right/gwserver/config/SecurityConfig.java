package com.get_tt_right.gwserver.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.web.server.SecurityWebFilterChain;

/** Update as of 12/07/2025
 * --------------------------
 * Another class level annotation we are going to use on top of this class is, @EnableWebFluxSecurity. Since Spring Cloud gateway is built based upon the Spring reactive module,we need to use the @EnableWebFluxSecurity annotation. If it were a normal non-reactive Spring/boot web application, we would have used the @EnableWebSecurity annotation.
 * Next, we are going to create a method inside this class named - springSecurityFilterChain. This method will create a bean and for that reason I mentioned a method level annotation i.e., @Bean. This method has the signature + SecurityWebFilterChain : springSecurityFilterChain(ServerHttpSecurity). Check the method level docstring for more details about this method.
 * As a next step, we should also tell to the resource server on how to validate the access token that it is going to receive from the client application. As of now, my resource server does not have any clue about what is the auth server, what is its endpoint url, what is the process that it needs to follow to validate the access token. To provide all these details to the resource server, we need to add some configurations inside the application.yml file.
 * Under the 'spring' element, we are going to create a new child property i.e., 'security.oauth2.resourceserver.jwt.jwk-set-uri' and set its value to: 'http://localhost:7080/realms/master/protocol/openid-connect/certs' This value is nothing but the auth server url using which my resource server can download the certificates during the start-up of this resource server application. From where did I get this url? Like we discussed before, inside the list of configurations found here - lh:7080/realms/master/.well-known/openid-configuration. I am going to use the same url to download the certificates. If you can search for a path that ends with 'certs', you will find the same url.
 * So what is the purpose of this url? During the start-up of the resource server, it is going to connect with the resource server and it is going to download a public certificate from the KeyCloak server. So, what is the purpose of this public certificate? Using this public certificate, my resource server can validate if a given access token is really issued by the KeyCloak auth server. If yes, is it a valid access token?  So all those checks on the access token it can perform with the help of this public certificate. The KeyCloak is going to have private certificates using which the KeyClaok can only issue the new tokens. Whereas with the help of this public certificate any server like our Resource server can validate if a given access token is really issued by the KeyCloak auth server and if it is a valid access token. They cannot really produce new tokens, but they should be able to validate if a given access token is valid or not.
 *
* */
@Configuration // because we will create some beans inside this class. So, to communicate the same to my Spring framework to create these beans during the startup, I need to add @Configuration annotation to this class.
@EnableWebFluxSecurity
public class SecurityConfig {
    /** springSecurityFilterChain behavior
     * ------------------------------------
     * Using the input parameter reference, serverHttpSecurity, I need to invoke the authorizeExchange() method which is going to accept some configurations. To this authorizeExchange() method, we need to pass lambda configurations implementation of Customizer<AuthorizeExchangeSpec>. So, I will give it a random reference i.e., exchanges. Using this reference you can mention/invoke anyExchange which means nothing but any kind of request. and on to of that fluently invoke authenticated() which means any kind of request you want it authenticated. This means that all the request which are coming towards your gatewayserver have to authenticated. For some reason - I.e in the lower environments i.e., development - if you want to permit everything you can invoke permitAll() method instead of authenticated() method.
     * But right now I don't want to go with completely authenticated() or completely permitAll(). I want to have some API's be accessible without any security whereas for other types of APIs, I want them to be protected so that only, only authenticated users can use them. To achieve this requirement, delete anyExchange().authenticated() / anyExchange().permitAll() methods and then on top of exchanges reference, fluently invoke pathMatchers() method. This has 3 different overloaded methods i.e.,
     *     pathMatchers(HttpMethod method) - This is going tto accept what is the http method type. This is what we will invoke. To it, we are going to pass the input HttpMethod.GET. So, for all the APIs inside my gatewayserver that support Http GET method, I want to permit all. That's why on top of pathMatchers(HttpMethod.GET) method, I am invoking permitAll() method. This means that, any client application can invoke the GET APIs inside my gatewayserver without any security. They can fetch the data and can process that on their side. Think like this is one of the business requirements where your ms's network is fine to send data in a read only mode. But if any client/someone is trying to perform a create or delete operation in your ms network then, only you want to enforce some security. Now, you should be clear about this standard we are trying to follow. Nothing but, All our GET API methods we are simply reading the data. That's why I am trying to provide the permitAll() for all such GET REST API methods in our ms's network. If needed you can also make them authenticated, that's all up to you. But since we want to learn all the various flavours of permitAll() and authenticated() I am trying to go with this approach.
     *  Now as a next step, we need to enforce some security for the remaining APIs . Fluently again invoke the pathMatchers method on top of permitAll() method. This time this patchMatchers method is to accept the String representation of antPatterns. Its signature is:
     *     pathMatchers(String... antPatterns) - antPatterns are nothing but API path's that I want to secure or I want to permitAll(). So as Input, I am going to mention an input which is any path which has a prefix of "eazybank/accounts/**". I want that authenticated so that only authenticated users can access. I will do the same for "eazybank/cards/**" and "eazybank/loans/**". With this, I will have secured all my accounts, cards and loans related REST APIs inside my gatewayserver. But since we have mentioned the configuration like: exchanges.pathMatchers(HttpMethod.GET).permitAll() as a first configuration, it will have a first priority which means if someone is trying to invoke the GET APIs inside the 3 patterns that we have just defined for accounts, cards and loans, then it will be permitted even though we have mentioned the configuration like: exchanges.pathMatchers("eazybank/accounts/**").authenticated() as a second configuration. Because, we are trying to give some first preference configurations to at the top. That's why all the GET REST APIs in all the 3 patterns/microservices will be permitted without any security. Apart from the GET APIs, all the other APIs will be authenticated due to the configuration like: exchanges.pathMatchers("eazybank/accounts/**").authenticated().
     *                                         - You may have a question like, can't we mention these patterns with the help of comma separated values? Yes you can, but I have a reason as to why I am maintaining each pattern configuration independently - this you will get to know in the coming sessions.
     * After we have defined these details, we need to invoke fluently on top of authorizeExchange(....) behavior a method which is oauth2ResourceServer(). With this we are trying to convert our gatewayserver as an OAUTH2 resource server. To this method/resource server, also we need to pass the configurations in a lambda style which are an implementation of Customizer<OAuth2ResourceServerSpec>. So I will create lambda expression variable i.e., oauth2ResourceServerSpec. Using this reference, I am going to invoke a method which is jwt(-). Reason is because, we are trying to use the JWT tokens. To this jwt method we need to pass an input like: Customizer.withDefaults() - With this, I am trying to tell to the Spring security framework that, please use the default configurations related to the JWT tokens. With this, we have mentioned all the required custom configurations with the help of this serverHttpSecurity reference.
     * Now, using the same serverHttpSecurity reference, I need to invoke the csrf method. This method takes a lambda implementation of Customizer<CsrfSpec>. With this, I am trying to disable the CSRF protection provided by the Spring security framework. Reason - CSRF protection is only needed when browsers are involved. Since in our scenario, there are no browsers involved we can disable this protection, otherwise all you POST/PUT/PATCH/DELETE requests will fail because you have not you have not handled the CSRF attacks. Details around CSRF we in details discussed inside our Spring security sessions. Check with your notes and slides for more details. Using the lambda reference i.e., csrfSpec, I am going to invoke disable() method. With this, I am trying to disable the CSRF protection provided by the Spring security framework.
     * At last, we need to build a return statement using the serverHttpSecurity reference. On top of this reference invoke the build() method which is going to return the object of type SecurityWebFilterChain which will be converted into a bean with the help of this @Bean annotation.
     * **/
    @Bean
    public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity serverHttpSecurity) {
        serverHttpSecurity.authorizeExchange(exchanges -> exchanges.pathMatchers(HttpMethod.GET).permitAll()
                .pathMatchers("eazybank/accounts/**").authenticated()
                .pathMatchers("eazybank/loans/**").authenticated()
                .pathMatchers("eazybank/cards/**").authenticated())
                .oauth2ResourceServer(oAuth2ResourceServerSpec -> oAuth2ResourceServerSpec.jwt(Customizer.withDefaults()));
        serverHttpSecurity.csrf(csrfSpec -> csrfSpec.disable());
        return serverHttpSecurity.build();
    }
}
