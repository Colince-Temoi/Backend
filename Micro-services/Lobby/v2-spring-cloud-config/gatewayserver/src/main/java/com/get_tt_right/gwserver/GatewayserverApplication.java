package com.get_tt_right.gwserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;

import java.time.LocalDateTime;

/** Update as of 22/3/2025
 * As of now we are trying to send the requests to the gateway server by using the application name in complete capital letters like, http://localhost:8072/ACCOUNTS/api/create, http://localhost:8072/LOANS/api/create, http://localhost:8072/CARDS/api/create etc. If we did in small case letters, like http://localhost:8072/accounts/api/create, http://localhost:8072/loans/api/create, http://localhost:8072/cards/api/create, then it will not work. You will happily get a 404 Not Found error.If you are comfortable and fine using capital letters then you should be good with the default behavior of the Gateway server. But mentioning something in the request with complete capital letters is very odd. Even we can't request our external client applications to send the request with the application name prefix being in strictly in capital letters. That will be a very wiered thing to ask or a wiered behavior inside our applications.
 * To overcome this, we can introduce a new configuration property in the application.yml file of the gateway server. So, under the spring.cloud.gateway.discovery.locator, we need to add a new property called 'lowerCaseServiceId' with the value of true. With this we are telling to our Gateway Server that, please accept the service name in lower case letters. Do a build and try to validate the same to verify that everything is working as expected. If you try to send the requests with the application name in upper case letters, it will not work this time.
 * This is how we will continue as when a url is in complete lower case, it looks much more professional, and ideally we should never use complete upper case letters inside a url path. With this, you should be clear about this small change that we have done.
 *
 * Implementing Custom Routing
 * ---------------------------
 * As of now, our Gateway Server is able to accept the external traffic and is able to forward the same request to the actual ms's and how it is able to do that is with the help of the routing details present in http://172.25.96.1:8072/actuator/gateway/routes that we exhaustively discussed previously as part of the default routing details. These details of course it fetched from the Eureka Server. The default behavior like we discussed, for example, if someone is going to send a request to the gateway server with a prefix like /accounts/** , then whatever filters and the uri configurations present here, http://172.25.96.1:8072/actuator/gateway/routes, will be triggered. This is the default behavior, and we already discussed about it. And with this default behavior, our external clients/applications need to send there requests to the gateway server by following url's like: http://localhost:8072/accounts/api/create, http://localhost:8072/loans/api/create, http://localhost:8072/cards/api/create etc.
 * Sometimes this default behavior may not be suitable for the projects. For example if I have a custom requirement like: I want my external client applications to send the request to the path like: http://localhost:8072/eazybank/accounts/api/create. This will look much more professional that since they are going to invoke the eazybank related ms's , this is going to make more sense like; inside the eazybank organization we have a ms with the name accounts and inside this accounts ms, we have a path like: /api/create. So, I feel this is going to look more professional to me and this is my custom requirement. The same I will follow for other ms's as well. i.e., http://localhost:8072/eazybank/loans/api/create, http://localhost:8072/eazybank/cards/api/create etc. Like for all my ms's I want the prefix like, /eazybank/** apart from just using the application logical names. i.e., /accounts/**, /loans/**, /cards/** etc. So, whenever you have these custom or dynamic routing related requirements, then in such scenarios, Spring cloud gateway also gives flexibility to developers to define their own custom routing configurations.
 * How to do this? Go to the main class of the gateway server and here we need to create a new method  which is going to return a bean. The return type of this method we have to mention as: RouteLocator. The method name can be anything, in our case I am giving eazyBankRouteConfig. It is going to have a public access modifier. It is going to take a parameter/input like RouteLocatorBuilder. Then inside the body of this method, we need to define our custom routing related configurations. On top of this method, annotate it with @Bean.
 * Inside this method I am going to write some logic return statement and post this return statement, on top of the method input parameter like routeLocatorBuilder, I am going to invoke the routes method then fluently invoke the route method which will allow us to define our custom routing configurations based on our requirements. Inside this route method, I am going to write a lambda expression which take an input 'p' to indicate path. On top of this p reference, I am going to invoke a method with the name 'path'.
 * To this path method,we need to provide what is the path that my external client applications are going to invoke. For accounts ms it is, "eazybank/accounts/**". After the prefix ** implies there can be any kind of path. So whenever a request is being received for this kind of path, I want to execute some fileters and that's why we need tp fluently invoke the filters method. To this filters method again, we should write a lambda expression to accommodsate our logic. It will take an input 'f' to indicate filters. On top of this f reference, I am going to invoke a method with the name 'rewritePath' . Using this rewritePath method, we are going to rewrite whatever path that we have received to some other ms specific path.
 * So inside this rewrite path, we need to provide some configurations i.e.,  regex like: "/eazybank/accounts/(?<segment>.*)", replace with: "/${segment}" By this, I am saying, after the prefix path /eazybank/accounts/, whetever path that follows or that is available please assume that as a segment. Using the same segment value or using the same path , I want the request to be forwarded to the actual ms. This kind of configuration if you are keen enough you can also see in the actuator routes that we discussed as part of the default configurations. i.e., if you check here http://172.25.96.1:8072/actuator/gateway/routes you will be able to see something like       "[[RewritePath /gatewayserver/?(?<remaining>.*) = '/${remaining}'], order = 1]"
 *  - There we have a placeholder like, 'remaining', instead of that, we have decided to use 'segment' as oue placeholder. So whatever comes after this 'accounts' prefix, I am calling that as a segment and whatever path I have inside this segment placeholder, I am considering that as the base path in second input parameter of the rewritePath method. This is what the gateway server will consider when trying to invoke the actual ms. Hope this is crisp clear to you. After mentioning this filter related information, we need to fluently invoke a method which is .uri using which we are going to provide configurations that, to which ms the request needs to be forwarded/re-directed. For the same I am mentioning,"lb://accounts" here 'lb' stands for load balancer. I am trying to tell to my Spring Cloud gateway that please perform the Client Side load balancing  with the help of Spring Cloud Load Balancer. And post that, we need to mention the application/ms name that is registered with the Eureka Server.
 *    That's why we need to mention the same name here i.e., "ACCOUNTS" Don't mention this in small letters like "accounts" because if you go and check the eureka dashboard, the application name will be in completely all capital letters. That's why we need to follow the same inside our custom routing configurations. Once we are done defining these information, we should be good from the accounts ms perspective. As a next step, I want to define similar kind of custom routing configurations for other ms's as well. Just copy whatever we have  for accounts ms and paste it for other ms's then modify appropriately.
 *  - Once we have defined all the custome related routing configurations, at last we can invoke the method like build(). And with this build method an object of type RouteLocator will be created, then converted as a bean with the help of this @Bean annotation and returned.
 *    With this my Gateway Server is going to identify a bean of type RouteLocator during the startup of the application and with that it can easily recognize that I have defined some custom routing configurations, and so I need to follow these custom routing configurations. We should be good with these custom changes. Save and do a build and run the application. Now, go to the postman and test the same by trying to invoke our ms's with request path having a prefix like http://localhost:8072/eazybank/accounts/api/create, http://localhost:8072/eazybank/loans/api/create etc. In our Postman collection under the folder 'gatewayserver' you will be able to see a request with the name 'gatewayserver_3' whose url matches the custom route configurations that we have defined. On Making this request, we are getting an error like: Invalid host: lb: ACCOUNTS whenever my gateway server tries to forward the request to the actual ms i.e., accounts ms. We made a mistake inside our routing configurations, we should make sure for uri, after the lb: we should have 2 forward slashes. With this everything should now work happily as expected.
 *    Very similarly, you can invoke the gatewayserver_4 request which is a fetch request and yeey! it also worked as expected. This way, you can also test the cards and loans ms's specific rest API's as well with the help of your Postman.
 *  - Now if you try to refresh the Gatewayserver actuator path i.e., http://172.25.96.1:8072/actuator/gateway/routes, you will see the custom routing configurations that I have defined as well alongside the default routing configurations. This is going to create a lot of confusion for my external client applications, and thus, it is always a good idea to follow a standard/single way of doing things. For me, the custom approach looks much more professional because we have the organization name as a prefix like /eazybank/** followed my the ms name and then the actual resource path. That's why what we can do is try to disable the default routing configurations behavior of the gatewayserver by assigning a value of false to the property 'spring.cloud.gateway.discovery.locator.enabled' inside the application.properties file. Now, if you try to refresh the Gatewayserver actuator path i.e., http://172.25.96.1:8072/actuator/gateway/routes, you will see only the custom routing configurations that I have defined. There will be no default routing configurations present that my gateway server fetched from the Eureka Server.
 *    As a next step, we can try to test one negative scenario by invoking gatewayserver_1 or gatewayserver_2 present inside our postman collection. In these requests, the url's don't have the prefix eazybank/** which means I am trying to go with the default routing configurations that my gateway server fetched from the Eureka Server though we have disabled the default routing configurations. So, these requests will fail with a 404 NOT FOUND error because we have disabled the default routing configurations and we told the gateway server to leverage only the custom routing configurations that I have defined that have a prefix like /eazybank/**.
 * Up to now, you should have clarity on whatever changes we have done inside the method eazyBankRouteConfig(RouteLocatorBuilder). Very simple indeed! Spring cloud gateway also supports defining these very custom configurations inside the application.yml file. For more details you can check out the official documentation. But, I will always recommend not to use that approach, always go with the Java based configuration approach because this will allow you to define more complex routing configurations, define more number of filters, whereas with the application.yml approach, it has some limitations.
 *
 * Visual demo of addResponseFilter
 * ---------------------------------
 * - As of now, inside our Gateway server we have defined our custom routing related configurations inside the method + eazyBankRouteConfig(RouteLocatorBuilder):RouteLocator. Inside those configurations, if you observe:
 *   . First we wrote a Predicate i.e., p -> p.path("/eazybank/accounts/**") with the help of this path predicate i.e., p.path("/eazybank/accounts/**"). Using this path predicate, we are trying to validate if the received/given request path matches to this predicate value i.e., "/eazybank/accounts/**". If true or if it matches,
 *     Then we are trying to invoke one of to predefine filters available inside the Spring Cloud Gateway server which is reWritePath. Using this filter, we are trying to rewrite whatever path that we have received(1st parameter) to a different path(2nd parameter) before we try to forward the request to the actual ms. Once the reWritePath filter is executed,
 *     Then we are trying to forward the request to the actual ms i.e., "lb://ACCOUNTS".
 * - Now, we want to see a demo on how to add more filters. As of now we only have one filter. But, in real projects we may want to define multiple filters and that's why to demo the same scenario, I want to intorduce one more filter which is responsible to send a header inside the response that we are going to send to the client applications. For the same, first, lets try to refer to the official documentation - https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/global-filters.html
 *  Before we dive into the addResponseFilter, lets see more details on how you need to approach this documentation anytime you have questions regarding the Spring Cloud Gateway or any other framework whatsoever. As of now, inside our method to define custom routing configurations you may be wondering like where did this guy get all this that he has written here!? And specifically in that particular format/fashion?  This is a very valid question and many at times you may have such questions.  Steps:
 *   1. First, you need to read the complete official documentation where usually we will have complete details.
 *     For example if you click on the LHS nav link in the documentation like: Fluent Java Routes API, here you can see we have a Java method with the definition very similar to what we have just written as part of our custom routing configurations. It has a @Bean annotation, it a accepts a return type of type RouteLocator and it accepts a parameter of type RouteLocatorBuilder. So, this is exactly what we have written here. And it is an official example from the Spring Cloud Gateway team.
 *     Very similarly, based on our own business requirements, we need to modify/change the contents of this method and tailor that to our needs and that's what we have done here. If you have a question like, how can we define routing related configurations with the help of yml configurations?  That's a very valid question and obviously you need to search in the official documentation, for example, on the if you click on the LHS navlink like : Route Predicate Factories. Here, you will see many predicate factories and the specific predicate factory that we have used is is related to the path and you can see this documented as part of the 'The Path Route Predicate Factory' - This you can clearly see on the RHS nav.
 *     If you click on it, you can see an example configuration that we can follow whenever we are trying to use .yml file.  You can see here i.e.,
 spring:
 cloud:
 gateway:
 routes:
 - id: path_route
 uri: https://example.org
 predicates:
 - Path=/red/{segment},/blue/{segment}
 * Using this yml configuration properties, we can define the same kind of information like, what is the id, what is the uri, what are the predicates and so on. And inside this predicates, we can mention/invoke the path predicate. So yea, this is another approach on how we can define Routing related configurations inside the Gateway server but like we concluded always prefer the Java style approach because it is very flexible and with it, you can implement any complex requirements.
 *
 * - Back to the topic we are trying to discuss, we are trying to add new filters responsible to send the header inside the response. For the same you can search through the official documentaion. You can try to locate the nav link: GatewayFilter Factories. On clicking, search for " response" string. You will see a a Gateway Filter factory like: AddResponseHeader GatewayFilter Factory. Using this filter factory, we can add a header inside the response and if you see, here they have given the configurations with the help of .yml fashion.
 *   But since we are using the Java based configurations approach, we need to locate for something veru similar. Go to the Java based configurations section and remember the filer name as can be seen in the .yml snippet which is 'AddResponseHeader' i.e.,
 *   spring:
 *   cloud:
 *     gateway:
 *       routes:
 *       - id: add_response_header_route
 *         uri: https://example.org
 *         filters:
 *         - AddResponseHeader=X-Response-Red, Blue
 * - In our method, + eazyBankRouteConfig(RouteLocatorBuilder):RouteLocator, we have defined only one filter as of now. To define one more filter, you can fluently do so just immediately after the first filter in this case just after the rewritePath filter.
 *    If you type dot (.) then Ctrl + tab, you will be able to see the complete list of all the predefine filters available inside the Spring Cloud Gateway server. The filter that we are looking for here is the 'addResponseHeader'. If you see its docstring, you can see it takes 2 inputs:  String headerName, String headerValue.
 *    So for me, I am going to consider the header name like 'X-Response-Time'. With this header name, I am going to consider the header value like the time at which I am trying to send what is the time at which I am trying to send the response to my client applications. This is going to help them understand when the response is received and at the same time if they're looking for some performance related information , they can always calculate when they send the request and when they receive the response and this will give them some rough estimate on how much time a particular request has taken to go to the GatewayServer and from here to the actual ms that is registered with the Eureka Server and back up to the client applications.
 *    As a value, obviously we need to send the current date and time. For the same, I am going to invoke LocalDateTime.now() then fluently invoke .toString(). With this, you can see that we have added new Filter that is responsible to send a header inside the response. The same filter I have added for other ms's routing configurations as well. Now, you can re-run your applications and try test if whatever you have done is working or not. Before that, for the previous request, gatewayserver_3, If you check the response header section, you can see that we used to get only 3 headers inside the response with key-Values like: transfer-encoding:chunked , Content-Type : application/json, Date : Sat, 22 Mar 2025 12:05:12 GMT.
 *    Now, if i try to send this request again to my gateway server, this time you will be able to see that we are getting a new custom header that I have defined inside the response with the key like 'X-Response-Time' and the value will be the current date and time. In this fashion, we can add any number of filters that we want based upon your business requirement. You can always fluently using the dot(.) operator and then ctrl + tab to see all the predefine filters that are available inside the Spring Cloud Gateway server and learn about them and even use them. Just like Saroj taught you! There is a a filter to add the request headers, add request parameters, change request uri, cache request body, circuit breaker, fallback headers, json to Grpc conversion, local response cache, map request header, modify request body, modify response body, prefix path, redirect, ...etc.
 * - Like this, there are a good amount of filters available inside the Spring Cloud Gateway Serve. So, based upon your business requirements always try to leverage them and with these filters you should be able to achieve the majority of the business requirements. What if there is no predefine filter inside the Gateway server that will match whatever business logic I want to perform at this filterarion level in the gateway server?  Well, In such scenarios definitely we need to define our own custom filters.
 *
 * Defining our own custom filters inside the gateway server
 * ----------------------------------------------------------
 * - Before trying to create these type of filters, first we have to decide on what kind of business logic we want to implement with these kind of custom filters. I want to take a business scenario where as soon as my Gateway server receives external traffic/request it has to generate a correlation Id which is a randomly generated value.
 *   The same correlation Id I want to send for all the further ms's where my request is going to travel. Maybe, I am trying to send a request from gateway server to accounts, from accounts to loans and cards. Then I want to make sure the same trace id /correlation id to be send to all the respective ms's. Using this trace/correlation id, I am going to add some logger statements inside the respective ms's. While I am sending the response back to the client, I want to add the same correlation id inside the response header so that in future, whenever my client has some issues with a particular request saying that, the data is not correct or there is an exception that happened. Using that correlation id , my developer can look at the logs and identify up to which ms the request has travelled and if there is an exception, under which ms the exception has happened. This is what we want to achieve with this custom filters.
 *   With the visual hands-on demo, things will be more clear for you. How to approach and structure things out for the case of custom filters inside the gateway server.
 * 1. Create a new package called com.get_tt_right.gwserver.filters inside the gatewayserver project. Inside this package only, we are going to create all our custom filters.
 *    Create a new class with the name: RequestTraceFilter - Its reponsibility is to generate a trace/correlation id whenever a new request comes to my gateway server from the external clinet applications.
 *    Create a new class with the name: ResponseTraceFilter - Its responsibility is to add the trace/correlation id inside the response header so that my client also is aware about the trace/correlation id that is associated with the  particular request.
 *    Create a new class with the name: FilterUtility - It will hold/define all the logic which is common to these RequestTraceFilter and ResponseTraceFilter classes.
 *  Inside these 3 classes, we need to write some good amount of logic, haha. So, let's try to understand what each and every line of code that we are writing in these 3 classes is doing. To save your valuable time, just copy, paste then understand what each and every line of code does with crisp clarity.
 *  # Check with the respective classes and understand what each and every line of code does as we have discussed that comprehensively.
 * */
@SpringBootApplication
public class GatewayserverApplication {

	public static void main(String[] args) {
		SpringApplication.run(GatewayserverApplication.class, args);
	}

	/* This method is going to create a bean of type RouteLocator and return it.
	* Inside this RouteLocator only, we are going to send all our custom routing related configurations based on our requirements.
	**/
	@Bean
	public RouteLocator eazyBankRouteConfig(RouteLocatorBuilder routeLocatorBuilder) {
		return routeLocatorBuilder.routes()
				.route(p -> p.path("/eazybank/accounts/**")
						.filters(f -> f.rewritePath("/eazybank/accounts/(?<segment>.*)", "/${segment}")
								.addResponseHeader("X-Response-Time", LocalDateTime.now().toString()))
						.uri("lb://ACCOUNTS"))
				.route(p -> p.path("/eazybank/loans/**")
						.filters(f -> f.rewritePath("/eazybank/loans/(?<segment>.*)", "/${segment}")
								.addResponseHeader("X-Response-Time",LocalDateTime.now().toString()))
						.uri("lb://LOANS"))
				.route(p -> p.path("/eazybank/cards/**")
						.filters(f -> f.rewritePath("/eazybank/cards/(?<segment>.*)", "/${segment}")
								.addResponseHeader("X-Response-Time",LocalDateTime.now().toString()))
						.uri("lb://CARDS")).build();
	}

}
