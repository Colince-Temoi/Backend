package com.get_tt_right.gwserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
/** Update as of 18/3/2025
 * We need to define some configurations inside the application.yml file of gatewayserver. Instead of typing all these properties again, we can go to any of the application.yml file of our existed ms's and copy all its contents and paste it inside our gatewayserver application.yml file. Now this way we can be able to modify by removing, adding or changing any of the properties inside the gatewayserver application.yml file to fit our needs. Now lets try to analyze each of the property and decide it is needed or not for a gatewayserver.
 * - server.port -> This I will maintain in the configserver that's why it is not needed here.
 * - spring.application.name -> This we need to retain here. Its value is going to be gatewayserver.
 * - We don't want any profiles configurations for gatewayserver because for all types of environments, the gatewayserver is going to work very similarly. With that reason, remove profiles.active property.
 * - We also don't need the datasource, h2 or your DB and jpa related configurations because the gatewayserver is not going to have any DB.
 * - spring.config.import -> We need this because we are going to use external configurations. Using this, my gatewayserver can connect with the configserver and load the configurations during the startup.
 * - For actuator related properties, we can retain all of them like:
 *   management.endpoints.web.exposure.include=*  -> We want to expose all the management related endpoints.
 *   management.endpoint.shutdown.enabled=true -> We don't want this shutdown endpoint. So remove it. We also don't need endpoints.shutdown.enabled=true.
 * - Retain the management.info related properties.
 * - Delete the eureka related configurations since we will be maintaining them inside the configserver. I don't see any reason of us maiantaining them here as I want my GatewayServer to be able to connect with the configserver and get at least some of the configurations from there. Nothing fancy.
 * -  under the info.app related properties modify the values to align with the gatewayserver.
 * As a next step, we need to add the below new configurations:
 *  management.endpoint.gateway.enabled=true - To enable the Gateway related endpoints inside the actuator. This is deprecated, you can find out the newest way of doing this.
 * Now we should be good, lets try to define some properties inside the configserver yaml file related to the gatewayserver. Check on the github repo 'configs' for the file gatewayserver.yml. In this file we have the below configurations defined:
 * - server.port - With this my gateway server is going to start at the port 8072
 * - eureka related configurations -> I want my GatewayServer to connect with the Eureka server so that it will know what are the actual endpoints of my ms's. The purpose of each and every of those eureka related confogurations/properties we already know. If you forgot, do a refresher on the knowledge you have documented around the same because we did an extensive discussion on that.
 *   These same properties we have defined inside the accounts, loans as well as cards ms's.
 *  In https://github.com/Colince-Temoi/configs we have the gatewayserver.yml file.
 * - Now,our gateway server will have enough details about our ms's . How it is going to get all these details? By connecting with the service discovery agent called EurekaServer.
 * - As a next step, we need to tell our gateway server that, please leverage the information available inside the discovery agent to forward all the requests that are coming from the external clients. To communicate this, we need to configure a property inside the gatewayserver application.yml file called spring.cloud.gateway.discovery.locator.enabled=true. With this configuration, I am telling to my gateway that please connect with the discovery server which is eureka server and locate all the details about all the registered ms's. Just form this properties name, it is communicative. i.e., the gatewayserver is going to connect with the discovery server and locate all the details about all the ms's.
 * Once it located all the information about all the individual ms's registered with the discovery server, I want my gatewayserver to use the same information to forward the traffic from external clients to the individual ms's. So, please make sure to mention this property and with this we should be good with all the changes so far inside the gatewayserver application.yml file. Next, we will try to start all the ms's along with the gatewayserver, eurekaserver and configserver and try to test few of the ms's by sending the request to the gatewayserver and see if it is able to forward the request to the actual ms's instead of directly making the request to the actual ms's.
 * Also, for a summary of all the important steps that we followed up to now, please check with our slide for your reference.
 *
 * Demo of Edge Server with default routing configs
 * -------------------------------------------------
 * - Before we start the Edge server, start the configserver, eurekaserver and all the ms's then only at the end you can start the Edge server. The reason is very simple, we want our Edge server to handle all the traffic towards the internal ms's that we have built. For the same it is going to connect with the Eureka Server to locate/fetch the details about all the internal ms's. So, please start the Edge server at the end. If your started the Gateway server first, then Eureka Server will not share any information about the internal ms's to the Edge server as they will have not been registered with the Eureka Server yet. That's why we need to always make sure that the Gateway server is the last server that you start.
 *   During the start-up my Edge server is going to connect with the Eureka Server to fetch the details about all the internal ms's. When you start your Edge server, it will start at the port 8072. First, you can try to check the Eureka dashboard.  Here you should be able to see your registered internal ms's. Along with them, you can also see your Gateway server which is also registered with the Eureka server. This you can also confirm by making the request like: http://localhost:8070/eureka/apps/gatewayserver in your postman.
 *   As a next step, I can try to invoke the actuator endpoint of my Edge Server from my browser i.e., http://172.25.96.1:8072/actuator You will get a Json response, and you should be able to see it in a proper format due to the plugin that you have installed inside your browser i.e., JSONView. In this response, if your search for the string 'gateway', towards the end of this response, you should be able to see an API path with the url http://172.25.96.1:8072/actuator/gateway . Open that link in a new tab and append to it the path '/routes' i.e., http://172.25.96.1:8072/actuator/gateway/routes. You will get some Json response inside which there is some information related to each of our internal ms's. Let's try to understand what each of these pieces of information communicates to us:
 *  1. "predicate": "Paths: [/ACCOUNTS/**], match trailing slash: true",
 *    - If someone is going to send a request to the Gateway Server which has a path of /ACCOUNTS/**, then this predicate is going to match/become true and the Gateway Server will forward the request to the Accounts ms by using the information under, metadata,uri, ..etc. as we will see in the next step.
 *  2.     "metadata": {
 *       "management.port": "8080"
 *     },
 *    - Once the predicate in step 1 is true, the information under this metadata i.e., management.port is going to be used by the Gateway Server to forward the request to the Accounts ms at the port 8080.
 *    - This port number information alone is not going to be sufficient to forward the request. See step 3.
 *  3.    "uri": "lb://ACCOUNTS",
 *   - Since the port information alone is not going to be sufficient to forward the request, the Edge server should also know where my actual Accounts ms is running. For the as a value to this 'uri' key we have something like: "lb://ACCOUNTS"
 *     . 'lb' indicates load balancer. And we are telling that, please redirect the request that we received at the Gateway server with the path of /ACCOUNTS/** to the URI with the loadbalancer and the App name as ACCOUNTS. This App name we have available inside the Eureka dashboard under the section 'Instances currently registered with Eureka'
 *     . This means, the Gateway server is going to leverage the service discovery agent and forward the request to one of the instances of Accounts ms by following the load balancing strategy with the help of Spring Cloud Load balancer.
 *    Apart from the port number and uri information that we have discussed, there is more information as discussed in the next step.
 *  4.     "filters": [
 *       "[[RewritePath /ACCOUNTS/?(?<remaining>.*) = '/${remaining}'], order = 1]"
 *     ],
 *   - Here, you can see that there is a filter configured for all the path's. Its purpose is, to re-write the path just as the name hints you. If you try to keen ly understand this, we are telling my Gateway Server to leverage the ' RewritePath ' fileter.
 *     What this filter is going to do is, whenever someone is going to send a request to the Gateway server with the path of /ACCOUNTS, after this you can see we have '/?' meaning after /ACCOUNTS, you can send any path value. So, with the help of this 'RewritePath ' filter, we are going to re-write that entire path that we have received i.e., RewritePath /ACCOUNTS/?(?<remaining>.*) to the path like '/${remaining}'.
 *     Which means, by the time my request is being forwarded to the actual Accounts ms, it is going to remove the prefix value of /ACCOUNTS from the path and forward the request to the actual Accounts ms with the path value of /${remaining} - Nothing but the path value whatever it has received after the prefix value of /ACCOUNTS i.e., /?(?<remaining>.*)
 *     We will see a visual demo on this and then everything will clearly make more sense.
 *   - We have more other information as seen in  the next step.
 *  5. "route_id": "ReactiveCompositeDiscoveryClient_ACCOUNTS",
 *   - This is a random route id that is generated by the Gateway Server. This is a unique id that is generated by the Gateway Server.
 *
 * All this information that we have discussed is going to be similar for all the other internal ms's i.e., Loans and Cards.
 * - Now, coming to the Gateway server information in this same actuator endpoint for GatewayServer i.e., http://172.25.96.1:8072/actuator/gateway/routes, we can see the same information as seen in step 1,2,3,4,5. This should just inform you that at the end of the day, My Edge server is also but an application as well. If someone wants to invoke some API which I can expose inside my Gateway server, the need to send a prefix path like /GATEWAYSERVER/**.
 *   In such scenarios, my Gateway server will redirect the request to itself with the help of the port 8072 and with the details available inside the Eureka Server with the name of 'GATEWAYSERVER'
 * - Now lets see a visual demo so that it will be clearer to you on how this routing is going to work. Inside our postman collection, we have a folder with the name, 'gatewayserver'. Inside you can see a request with the name 'gatewayserver_1' and the url as http://localhost:8072/accounts/api/create. Here I want to create a new Account by invoking the create API available inside the Accounts ms. But I don't want to directly invoke the Accounts ms running at port 8080.
 *   Because right now we have an Edge Server which is sitting inside our ms network. The same I want to use.  In the url, you can see the port that we have mentioned there is 8072 which is where my Edge Server is running. After the port number, we need to mention what is the logical name/the application name that your ms registered with the discovery server. i.e., the name of the ms i.e., 'accounts'. Make sure you mention this name in capital letters because by default the Eureka Server applications will be registered with names as capital letters. If you try with small letters, it will not work as you will experience a 404 error.
 *   You can also see the same application name inside the gateway routes i.e., http://172.25.96.1:8072/actuator/gateway/routes. If someone is going to send a request to my Edge Server with the path of /ACCOUNTS/**, then this GatewayServer is going to execute all the logic based upon the default configurations available as discussed earlier in the steps 1,2,3,4,5.
 *   So, in your request inside postman, after mentioning the logical/application name, you need to mention what is the actual path that you want to invoke inside your individual ms like api/create present inside Accounts ms. To this we need to forward the request body consisting of inputs like name, email and mobile number. Technically speaking, if you see, I am sending the request to the Gateway server but behind the scenes, this Gateway server is going to locate the routing related configurations matching with the logical name i.e., ACCOUNTS. Whenever it finds some routing related information matching with the logical name i.e., ACCOUNTS, it is going to redirect the request by removing the prefix value of /ACCOUNTS and simply forward the remaining part of the path i.e., /api/create. All this we discussed in the steps 1,2,3,4,5. And to where it is going to redirect the request? This we discussed as part of the 'uri' key in step 3 which has a value of 'lb://ACCOUNTS'.
 *   Which we said that the Gateway server is going to use the load balancer to forward the request to one of the instances of the Accounts ms. If you make the request in postman, you will get a successful response from the Accounts ms with a status code of 200. You can also try the other requests present inside your postman collection i.e., gatewayserver_2, gatewayserver_3 etc. Similarly, if you want to invoke the loans ms API's like create, get etc. then you can also do the same thing. The external clients need to send requests with a prefix path like /LOANS/** and the Gateway server will redirect the request to the actual Loans ms with the help of the load balancer and the port number.
 *   This way, now my external traffic I can request my external client applications to send to my Edge server and then the Edge server will redirect the request to the actual ms's with the help of the load balancer and the port number. This way we are not exposing our individual ms's to the outside world/external client applications. You may have a question like, who is stopping our external clients from directly invoking the actual individual ms's like Accounts, Loans and Cards. Of course with this setup that we have up to now, my external clients can invoke the direct URLs also. But this is not the way to go. In the coming sections we will enhance our applications so that our external clients cannot directly invoke the actual ms's.
 *   We will enforce some security rules so that our external clients cannot directly invoke the actual ms's and all the external traffic will have to come only through the Gateway server.
 * - So far, we have been able to set up an edge server inside our ms's network quickly with the default configurations. We will further try to optimize it later but for now, you should be clear with whatever xchanges that we have done.
 * */
@SpringBootApplication
public class GatewayserverApplication {

	public static void main(String[] args) {
		SpringApplication.run(GatewayserverApplication.class, args);
	}

}
