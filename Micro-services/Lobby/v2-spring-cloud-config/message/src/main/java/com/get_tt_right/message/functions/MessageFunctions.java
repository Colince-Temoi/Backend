package com.get_tt_right.message.functions;

import com.get_tt_right.message.dto.AccountsMsgDto;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.function.Function;

/**
 *  I am going to mention a class level annotation i.e., @Configuration on top of this class.
 *  As a next step, we need to write business logic inside this class with the help of functions.
 *  I have created a logger variable with the name 'log' as we will be performing some logging inside my functions.
 *  Now, lets write our business logic with the help of functions. First, we will define our method with the signature + Function<T,R> : name_to_my_function
 *   '+' represents the access modifier, which in this case is 'public'.
 *   'Function<T,R>' is a type of object that is going to be returned by this method. In this case, we are going to return a 'Function' object. This Function object type is available inside the Java core library. If you open it, you will see its generic it accepts 2 parameters <T, R> where 'T' is the type of input, and 'R' is the type of output. So, whatever data you mention in the very first place of the angle brackets, that is going to be the input type and whatever data you mention in the very second place of the angle brackets, that is going to be the output/return type. This Function is a functional interface as can be seen from the annotation @FunctionalInterface. That means whenever we want to use this functional interface to implement our business logic, we need to provide a lambda expression which is going to accept an input and return an output.
 *      So, for the Function, the input parameter that I want to accept is 'AccountsMsgDto' - because my Accounts ms is going to send the message to the message broker in the format of this dto and the message broker is going to forward the same input to my function. For the output parameter that I am going to mention 'AccountsMsgDto' again - later we will understand why I am doing this - sending the same data type as an output from my function.
 *   'name_to_my_function' is the name of the function that I am going to create. i.e., 'email'
 *  After the function name, I am going to open 2 curly braces inside which I am going to write a lambda method which is going to act as an implementation logic for my functional interface of type Function<T,R>. Since we are going to return an entire lambda method/expression as a return type for this function, we will first mention the return keyword. Then mention the lambda expression input placeholder/variable name i.e., 'accountsMsgDto'. After this variable name, I am going to mention the lambda symbol i.e., '->' after that I am going to mention curly braces inside which I am going to write my business logic. So, from this function i.e., email, we are trying to return the implementation logic of my functional interface.
 *  We are not going to build the actual logic of sending email to the end user because that will deviate all our discussion from ms's as we want to focus more on the concepts i.e., Spring Cloud Function, Spring Cloud Stream, Asynchronous Communication, RabbitMQ, etc. That's the reason we are not going to implement a lot of business logic here just to make sure we are not loosing our focus. Assume like, whenever the log statement is printed in the lambda expression, we are going to email the end user. Post that, the same input, I am trying to return from my lambda method/expression.
 *  If you see the implementation, it is matching with my functional interface of type Function<T,R>. We are accepting an input of type 'AccountsMsgDto' with the variable name 'accountsMsgDto' and returning an output of type 'AccountsMsgDto'. This is revision for you as you understand Generics, Lambda expressions as well as Functional Interfaces available inside Java 8. So, now, we have created a function and inside this function we have created a lambda expression/method which is going to act as my business logic.
 *  As a next step, in order to make sure that this function is going to be monitored by the Spring Cloud Function, we need to annotate this function with the @Bean annotation. If you see here, with this email function, I am only sending the email to the end-user. How about the sms? For sms, I am creating one more function as shown below. Just copy and paste the things and rename the function name. Also change the logger statement to indicate sending of sms. The input type will remain the same. The output type, I want to mention as 'Long' as I want to return the account number. Since we have created the AccountsMsgDto as a record class, we will not have getter methods with the prefix value as 'get', instead we are going to have access to the getter methods directly with the name of the fields. For example, to get the accountNumber, we will write 'accountsMsgDto.accountNumber()' instead of 'accountsMsgDto.getAccountNumber()'. And since my account number is f type Long, and it is matching with the return type of my Functional interface, we will not face any compilation issues.
 *  Now, lets try to understand for the email function why I am trying to follow the input and output types as AccountsMsgDto type only i.e., Function<AccountsMsgDto, AccountsMsgDto> and for the sms function why I am using 'Long' output as a return type. The business logic that I want to build with these 2 functions is; My accounts ms will send a message to my message broker and my message broker is going to is going to invoke one of the functions which is email and to this email function the input is going to be AccountsMgDto. So, whenever my message broker is invoking my email function, behind the scenes I also want to invoke the sms function. How can we achieve this? haha I am going to compose both these 2 functions i.e., email and sms as a single logical unit. Nothing but I can write both these logic inside a single function. But since I want us to see the various features available inside the Spring Cloud function, I am trying to build 2 different functions as seen. And here since we want to compose two different functions, I am making sure that my function 1 i.e., email is giving the input data which is required for my function2 i.e., sms. My sms function also needs all the information that we received from the accounts ms. That's why I am trying to return the same object from my email function. When we compose these 2 functions the email function return type is going to act as an input for the sms function.
 *   And inside my sms function, once I executed all the business logic, I am going to return the account number which is of Long type. The reason why we are sending the account number as a return type from the sms function is: Once sending the communication details to the end user is completed, I want to let my accounts ms know that this process is completed. That's why I am going to send a message to my accounts ms as a response asynchronously with the account number as an input message value. Using this account number, my accounts ms can fetch the existing record from the db and we are going to introduce a new column inside our accounts table to update whether the communication is successfully sent or not. With this clarity, you now understand why we are using the respective input and output parameters of our email and sms functions.
 *  And btw, we have created our functions only with the help of Function functional interface. Similar to Function functional interface, we also have other functional interfaces which are supported by Spring Cloud Function i.e., Supplier, Consumer, etc. Supplier<T> is only going to have one generic argument and the T here indicates the type of results that we are going to return/supply from this Supplier. Whenever you have a scenario where you are not going to accept any input but you are going to send an output, then always write your business logic with the help of this Supplier functional interface. Consumer<T> is also only going to have one generic argument and the T here indicates the type of input that we are going to accept. So, in scenarios where your business logic is simply going to accept the input but not going to return any output, then always write your business logic with the help of this Consumer functional interface. So, far you should have crisp clarity of the 2 functions, email and sms, that we have created.
 *  Since we are done writing our logic using Spring Cloud function, now its time to see and visualize the full swing power of Spring Cloud function. Let alone your traditional Spring Boot application approach that you know of where you write REST APIs with annotations in the controller, service and dao layers. haha.
 *  As of now, you can see I simply just wrote functions and inside these functions, I have written my business logic. Actually, these are very normal methods that any developer can write, nothing fancy. Now, to convert these functions as a REST APIs, I can simply go to my pom.xml and add a new dependency i.e., spring-cloud-starter-function-web. Now, in your message service main class, start your application in debug mode. This will start my message service at the default port 8080. In the console logs you can clearly see that all my functions are recognized by the Spring Cloud Function and that's why you are able to see the log related to FunctionalCatalog. Now, its time to experience the magic, haha. Inside my postman there is a folder under microservices collection called 'message'. Inside this we have a request with the name 'email'. So I am trying to invoke my API which is available at the port 8080 and the endpoint name/path is going to be the function name i.e., email. And to my function what is the input? Yes, AccountsMsgDto which is going to accept the fields defined inside it. The same thing is what we have defined in our request body. Before trying to invoke this REST API put a breakpoint inside you function at the first line in the lambda expression. And then you can try to invoke this REST API using postman. You should see the breakpoint is hit. As soon as you release the breakpoint, in the console you should be able to see any logs we have mentioned in our function(s). This clearly tells you that the business logic mentioned in our function is working as expected/ Is being executed.
 *   Did we develop any traditional REST APIs? No, we simply wrote our business logic as functions. By simply adding a dependency i.e., spring-cloud-starter-function-web, all my functions will get recognized by Spring Cloud Function and hence, all the functions will be available as REST APIs inside your message service. This is f**ing happening automatically. This is one of the feature of Spring Cloud function. Similarly, I can change my functions to work in different styles, maybe I can try to integrate these functions with event brokers like RabbitMQ, Kafka, etc. Or maybe, I can simply deploy these functions as a standalone service/application inside any serverless platform like AWS Lambda, Azure Functions, etc. That's the power of Spring Cloud Function, especially if you are building event driven microservices - It is always advisable to build your business logic with the help of Functions and this will give flexibility to you to deploy your functions in whatever style you want. In the response in our postman, you can clearly see we are getting whatever value we send as input in the request body. Its because, like discussed before, we are sending/returning the same input object from our function as an output. You can also test the sms request. Make sure that you are also sending the input i.e., AccountsMsgDto in a Json format in the request body and yes, the execution of our sms function will be triggered and the breakpoint will be hit confirming that your sms function is also exposed as a REST API. On resuming the execution/releasing the breakpoint you should receive the expected output in the response in your postman and also, you should be able to see your console logs confirming that your sms function is also working as expected.
 *   Inside the postman response for the sms endpoint, you should be able to see we are getting the account number that we send as part of the request. The reason is: the sms function is going to return the account number which is of type 'Long' as an output. So, with these functions, it gives flexibility to your clients to invoke email or sms functions as REST APIs whenever your client application or ms wants to send only email communications or only sms communications just like we have seen in the demo. But, apart from invoking these functions independently or individually, I also want to give flexibility to my clients to invoke a REST API which is going to invoke both these 2 functions as a single logical unit. How to achieve that? we need to compose our functions. In order to compose our functions as a single logical unit, we need to go to the application.yml file. Okay, as of now we have application.yml file, so rename it to application.yml. Here I am going to mention the parent property like server the a child i.e., port and assign to it a value i.e., 9010 because at the default port which is 8080, our accounts ms is going to start. To avoid port conflict issues, I am giving a different port number for my message ms. Next I will define the spring.application.name property - Later we will use this property. Under the spring parent property I am going to mention cloud.function.definition and assign the value as your function names separated by a pipe symbol. With this pipe symbol, I am trying to compose the 2 functions email and sms as a single logical unit. And this is how you can compose functions as a single logical unit. Similarly, you can compose any number of functions as a single logical unit with the help of pipe symbol.
 *   Now, save your changes and restart your service and this time it should start at the port 9010. Now, remove any breakpoint that you have ein your functions that we had set earlier and as a next step you can try to test your email and sms functions one more time. Yes, they are working just fine. This tells us that, there is no impact to the individual REST APIs/functions due to the spring.cloud.definition of functions that we have defined. Ready for more magic, open the next request in our message folder in postman i.e., emailsms. Whenever you try to compose multiple functions, it is going to expose a REST API with a name by combining all your functions in the order which you composed them. So, email is the first function and post that sms and so our REST end point would be emailsms. For this emailsms endpoint, since the 1st function is going to be invoked, we need to send the request body input in the format that your email function input is expecting. When you invoke this endpoint, we are getting an output of accountNumber. If you cleaned the console before invoking this endpoint, now if you go check it, you can see what happened behind the scenes from the console logs. You should be able to see log(s) from email function as well as those from sms function. This confirms that these 2 functions are composed and being executed as a single logical unit. I hope you are able to see the power fo Spring Cloud function, how you are able to expose the functions as REST APIs, how you are able to compose multiple functions as a single logical unit and how you are able to invoke these functions as a single logical unit. This is just one of the many features that Spring Cloud function provides. For us, we are not focusing on building our functions as REST APIs, instead, we want to integrate these functions with one of the event/message brokers which is RabbitMQ.
 * To integrate you functions with RabbitMQ or any other event streaming model, you need to use Spring Cloud Stream as well alongside Spring Cloud Function. From the next session, we will try to understand what is Spring Cloud Stream and how we can leverage that inside our message ms. Before then, roll back the REST API changes i.e., Comment out the spring-cloud-starter-function-web dependency in the pom.xml file. Reason: I don't want to expose my functions as REST APIs. For the properties we have defined in the application.yml file, we don't need to delete them as we will need/use them when we try to integrate our functions with event/message brokers like RabbitMQ. You should be super clear and like Spring Cloud Functions. When I try to integrate Spring Cloud Functions alongside Spring Cloud Stream and event/message brokers like RabbitMQ, prepare to experience a woow! feeling of magic.
 *
 * Why to Use Spring Cloud Stream?
 * ---------------------------------
 * We saw the demo of Spring Cloud Function. In this session we will explore what is Spring Cloud Stream and what are the advantages/abilities it is going to provide to us. Before we dive into Spring Cloud Stream, all the Steps that we followed while doing a demo on Spring Cloud Function, starting from building the business logic. I have highlighted them for you quick reference in the slides before you go for any interview or any project discussion.
 * Check slide for more details around Spring Cloud Stream.
 * Website of Spring Cloud Stream - https://spring.io/projects/spring-cloud-stream
 * ------------------------------------------------------------------------------------
 * - If you try to read the overview details of this Spring Cloud Stream, they are clearly telling that with the help of Spring Cloud Stream, we can build highly scalable event driven microservices. You can check more details from the website. The main information that I want you to understand here is, under the section 'Binder Implementations', you can see Spring Cloud Stream supports a variety of binder implementations like; RabbitMQ, Apache Kafka, Kafka Streams, Apache Pulsar, Amazon Kinesis, Google PubSub (partner maintained), Solace PubSub+ (partner maintained), Oracle TxEventQ_(partner maintained)_, Azure Event Hubs (partner maintained), Azure Service Bus (partner maintained), AWS SNS (partner maintained), Apache RocketMQ (partner maintained). So, behind the scenes, it is going to support all these binder implementations by simply adding there respective dependency inside the pom.xml file. And just like we discussed, you can also be able to notice a section 'The core building blocks of Spring Cloud Stream'  - something that we have already discussed in our slides as well. With all that, you should be super clear on what the purpose of Spring Cloud Stream is and why we are trying to use the same.
 *
 * Update message & accounts microservices to stream & process the events
 * ----------------------------------------------------------------------
 * Now, it's the time to leverage Spring Cloud Stream inside our ms's. First we are going to make few changes inside our message ms to integrate my functions with RabbitMQ. Inside the pom.xml, remove/comment out all the dependencies that we have from our previous sessions i.e., spring-boot-starter-test,spring-cloud-function-context,spring-boot-starter. Now, add the dependencies i.e.,spring-cloud-stream,spring-cloud-stream-binder-rabbit, spring-boot-starter-test, spring-cloud-stream-test-binder. Check the pom.xml file for more details around these dependencies.
 * Here, the main important dependencies are - spring-cloud-stream and spring-cloud-stream-binder-rabbit. You may have a question like; why have you removed the Spring Cloud Function related dependency. Reason: Whenever we add Spring Cloud Stream dependency inside our project, internally it is also going to add Spring Cloud Function related dependencies. So, just to avoid the that redundancy, I have deleted the dependency of Spring Cloud Function.  With this, we should be good from dependencies perspective. As a next step, inside this pom.xml, at the end, as you can see we don't have plugin details related to to Google Jib, since in coming sessions, we are going to generate a docker image for message ms, it's better to add the plugin details related to the Google Jib. Now, from pom.xml perspective, we should be good. As a next step, we need to add few properties inside our application.yml file i.e., Under the parent element spring.cloud.stream.bindings.'binding_name_you_want_give'. - Like we said before, Spring Cloud Stream bindings are going to establish an integration between the message broker with your functions. So, for the binding name I am giving 'emailsms-in-0'. Like based upon the function name we defined, I have chose this name. Next, in the binding name 'in' indicates that this is going to act as an input binding, then followed by hyphen zero. If you don't define these binding names, the binding name that we have configured is actually the default naming convention that your Spring Cloud Stream is going to follow. Because, since you have defined the definition i.e., spring.cloud.function.definition = email|sms, by composing them, it is going to take the 'binding_name' as emailsms and since it is going to create the input binding, it is going to append an hyphen followed by 'in' and then followed by hyphen zero which is the starting index value. So, I am trying to, follow the same default naming convention and provide the binding name here i.e., emailsms-in-0.
 * After the stream binding name i.e.,emailsms-in-0, we need to provide the destination. So, with the binding name, my Spring cloud Stream is going to have my function details like email and sms just like we composed them using the spring.function.definition. Right now, it doesn't have the queue it has to connect to or monitor so that any messages that comes to the queue, it is going to redirect those messages to the functions that we have defined. So, to provide the same information to the Spring Cloud Stream,under the parent property i.e., spring.cloud.stream.bindings.'binding_name_you_want_give'. we need to configure/define the 'destination' property and assign it a value i.e., 'send-communication', this is just but a random name. With this, inside my RabbitMQ, there has to be a queue with the name 'send-communication'. If you try to see the illustration we have in our slide 179 (Check the LHS of the Illustration), whenever we are using input destination binding, your functions are going to be binded to the queues (Visualize it like from functions to queues). Since here in our application.yml file we are defining some input binding, because we have mention 'hyphen n' inside the binding name, the destination that we have defined is going to be considered as a queue name by your Spring Cloud Stream. After the destination property, I am also mentioning another child property to spring.cloud.stream.bindings.'binding_name_you_want_give'. i.e., 'group' To this group property, we are trying to pass the application name, the purpose of this group property is - If we don't mention this group property, then my RabbitMQ is going to append some randomly generated value to my destination names, to my channel names and queue names. So, to avoid that and to have some consistent behavior, I am trying to define/give a group name. When we try to check our RabbitMQ console, then it will make more sense to you. Once we have defined these Stream binding details, we need to define the RabbitMQ details in the application.yml file as well.
 * Since we are trying to use the RabbitMQ message broker, we need to provide the connection details, for the same just under the Spring property , we need to make sure we are defining the properties with the element 'rabbitmq'. Under this rabbitmq element, we need to pass/define what is the hostname, port number, username, password and connection_timeout. Whatever I have mentioned for rabbitmq configurations i.e., host: localhost, port: 5672, username: guest, password: guest, connection-timeout: 10s. All these are default values. With this, we have made all the changes required to convert our message ms as an event driven ms. Now, it is capable of receiving the messages from a queue with the name 'send-communication'  available inside the RabbitMQ and sending emails or sms to the recipients. As a next step, we need to update the accounts ms to send the messages and push them into the RabbitMQ. Inside my accounts ms inside the pom.xml, add dependencies related to Spring Cloud Stream and RabbitMQ binder. At the end of the dependencies element near the dependency related to springdoc-openapi-starter-webmvc-ui, add the following dependencies - spring-cloud-stream and spring-cloud-stream-binder-rabbit. The same dependencie we added inside the message ms as well. You can copy them from there. Also make sure to update the tag name under the jib plugin to V10. After making these changes in the accounts pom.xml, I am going to create a dto class in the accounts ms i.e., AccountsMsgDto. This is very similar to what we created in the message service. Actually its a record class - just copy it and paste it under the account dto package.
 * As a next step, whenever we are trying to create a new account inside accounts ms, we need to make sure we are triggering an event into the message broker. For the same lets add some properties inside the application.yml file of accounts ms i.e., In the same position where we have spring.cloud as parent. Under this define a new child property i.e., stream.bindings.'binding_name_that_you_want_to_give'. So I gave the binding name i.e., sendCommunication-out-0. Inside our accounts ms, we don't have any functions defined as of now. Hope you remember why I am saying this? haha. It is because, like we know, by default the binding name is always derrived from the function names to our defined function. So, here we have just gave any random name. But remember it has to make sense. So, the binding name that I am trying to give her is 'sendCommunication-out-0' This is an output binding type, that's why we need to give 'hyphen out' followed by 'hyphen and zero'. For this binding, the destination is going to be 'send-communication'. So, with this destination name, my RabbitMQ is going to bind the output destination binding to an exchange available inside the RabbitMQ. And what is the exchange, it is going to be 'send-communication'. So, whenever we are using output binding, the destination value is going to be the 'exchange' name. Whereas, whenever we are using the input binding, like we did inside the message ms, the destination value is going to be the 'queue' name. After defining these stream binding related information, we should also define the RabbitMQ related connection details/configurations just like we did inside the message ms. So, under the spring parent element, paste the rabbitmq related properties. Actually this was even already in place when we were using RabbitMQ previously in some other sessions related to config server. Just add the 'connection-timeout' property as its what we hadn't added.
 * The next change we are going to effect inside the account ms will be inside the service.impl package where we are trying to create the account details. Inside my AccountsServiceImpl class, there is a method with the name 'createAccount', from this behavior only, I need to trigger an event/message whenever I successfully create a new account. Before I try to write any logic in this behavior, create a class level logging attribute with the name log as we want to perform some logging. Post that, I want to autowire a class level secondary type / bean of type StreamBridge. Since I have mentioned this as a variable inside this class and I have mentioned the @AllArgsConstructor class level annotation, the autowiring is going to happen automatically for any secondary type I have defined in this class. That means behind the scenes, my Spring cloud stream, is going to create a bean of StreamBridge and the same is going to be injected into this class. In the behavior createAccount, I am trying to save the customer details first and then post that I am trying to save the account details. So, whatever accounts details I saved, I will try to catch them in a variable so that, I can try to refer to them in my logic, So, I have stored the things in a new variable i.e.,Accounts savedAccount, which we are receiving from the save method. Now, just after the create account method, I am going to create a private method witrh the name 'sendCommunication'. The same 'sendCommunication' behavior, I am going to invoke it from the 'createAccount' behavior just after successfully saving the accounts information. While invoking this 'sendCommunication' method, I am going to pass 2 input parameters i.e. savedAccount,and savedCustomer. Now lets try to understand what is present inside this sendCommunication' behavior. Check its docstring for more details.
 *With all this, you should be able to establish a link between accounts ms, RabbitMQ and message ms. When we see the demo, its is going to be super clear for you. With this we have now made all the required changes in the messages and accounts ms. We have added all the dependencies related to Spring Cloud Stream and RabbitMQ. As a next step, we can try to start our ms's along with the RabbitMQ and try to visualize the demo.
 *
 * Demo of Async communication or event streaming using Rabbit MQ
 * ---------------------------------------------------------------
 * Now it's the time of visualizing the demo of triggering an event from accounts ms to message ms with the help of RabbitMQ. To get started with the demo, first, we need to make sure we started and set up the RabbitMQ. To start the RabbitMQ, we need to run a docker command. To know what is the docker command that we need to run, visit the RabbitMQ.com website >> Click on Getting Started >> Download and Installation >> You should be able to see a docker run command i.e., docker run -d -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:4.0-management. Now, if you run this command, you should get a container id as an output. I can lso confirm if my RabbitMQ started successfully or not by checking inside the docker desktop. As a next step, we can start our ms's. Inside our workspace, we can start our configserver first >> Eureka Server >> Accounts ms >> Message ms >> Gatewayserver. We don't need to start loans and cards ms's because we don't make any changes in them and we are not going to test any scenarios related to loans and cards.
 * And btw, just in case you forgot, our gatewayserver is going to act as a resource server since we have secured it with the help of Spring Security. So, to test my scenarios, I should also start my KeyCloak server which is going to act as my auth server. Inside my docker containers, I have a keycloak container in a stopped mode. I will try to start the same. It's good you didn't delete it,because if you do, everytime you spin a new container you will be needed to set up the client details, roles information. So To avoid that, we should make sure that we are only stopping the container but not deleting it whenever we are not using it. Now, lets see the RabbitMQ console, the url that we need to access to check the RabbitMQ console is - lh:15672. Enter the default username and pwd as 'guest'. Inside this UI, we are more interested in the 'Exchanges' and 'Queue and Streams' tabs. Under the exchanges tab, you can see under the 'name' column, there is an exchange created with the name 'send-communication'. The same we have defined inside the accounts ms application.yml file as a destination. If you try to click on this 'send-communication' channel/exchange, and try to expound the 'Bindings', you should be able to see the queue name i.e., 'send-communication.message' where the message will be redirected whenever this exchange/channel receives a message. The queue name is 'send-communication.message'. You can also verify if the queue is created or not by clicking on the 'queues and streams' tab. If you see the 'send-communication.message' queue, then we are good to go. If you see the 'send-communication.message' queue, then we are good to go. This we have provided inside the application.yml file of message ms. If you check the application.yml file of message ms you can see the destination configuration is 'send-communication' and you should also see a 'group' configuration whose value is the message ms application name and that's why in our RabbitMQ UI under the tab of 'Queues and Streams' we can see 'send-communication.message' queue. That's how this is coming about.
 * It is also worth noting that inside the application.yml file of message ms, we so far only defined the input binding i.e., emailsms-in-0. With this input binding, we are trying to bind this input binding to the message queue with the name 'send-communication.message', but of you see the exchanges information inside the RabbitMQ UI, we also have an output binding created with the name 'emailsms-out-0'. Hope you know why? haha. This is because, by default, whenever you add the spring cloud stream dependency to your ms where you have defined functions with the help of spring cloud function, the spring cloud stream is automatically going to create the input bindings and output bindings based upon the function definition configured in the application.yml file. Hope you clearly remember this. And btw be very careful with every letter you are writing in this docstring as it means volumes, because remember we are learning a framework which is already highly automated and a lot of things happen behind the scenes that you need to pay attention to. So in my function definition configuration I have 'definition: email|sms' because I tried to compose these 2 functions as a single function. That's why using the same spring cloud function definition name, an output binding was created for us automatically behind the scenes even though we did not create it explicitly like we did for the input binding i.e., 'emailsms-in-0'. And btw for this input binding, we also defined explicitly the destination details and that's why inside the RabbitMQ UI under the 'queues and streams' tab, our input binding is binded to the queue named 'send-communication.message'. For the 'emailsms-out-0' output binding, we have not defined the destination details, because that is going to be created automatically behind the scenes. Which means we have not binded it to any of the RabbitMQ components and that's why if you click on it you can see that this exchange does not have any bindings. This is the default exchange created by Spring Cloud Stream behind the scenes. As of now, it has no bindings. Later on, we will try to update this
 * Right now, our focus is on the 'send-communication.message' queue/channel and whose exchange is 'send-communication'. As a next step, we can try to invoke the create account API available inside accounts ms. Inside postman, go to the folder which is 'gatewayserver_security' and here we have a request which is ' Accounts_POST_ClientCredentials'. So, using the client credentials approach, I am going to create an account. If you click on the send button, obviously you should get a 401 unauthorized haha. So, you need to get an access token first, this you know. So make sure you have mentioned the client id and client secret correctly. All these details you know where to get them inside the KeyCloak UI console. Once you get an access token, you can send the request and this time you should get a successful response. Inside the RabbitMQ console UI, you should be able to see some changes. There is a message received and that's why inside the graph labelled, 'Messages Rates', you should be able to see a spike. If you go to the console of accounts application, you should be able to see a logger with message i.e., 'Sending Communication request for the details:....'. And the next log statements, you can see it is trying to connect to the RabbitMQ and send a message. As soon as the message is send, immediately we are receiving a log message i.e., 'Is the Communication request successfully triggered ? : true'. Since we received the boolean 'true' we are printing the same here. As a next step, if you go to the message application, here you will be able to see log statements like, 'Sending email with the details received..' and 'Sending sms with the details received...'. YYu should have crisp clarity now. Okay, lets now try to see the demo in a slow motion. During this slow motion deom, we are going to experience the power of asynchronous communication or event streaming ms's. Now, clean all the logs inside the message and the accounts applications. Post that I am going to keep a breakpoint just inside my email function because this is the very first function which is going to be triggered whenever a message is received inside my RabbitMQ.
 * Now create a new account, Once you click on the send button, you should be able to get an immediate response in the postman console within 1 sec, but we put a breakpoint inside message ms. You can navigate to the debugging console of message ms and let's see what is happening there. As of now, the message ms has not processed the input message received. This confirms that my accounts ms is not waiting for my message ms response. The responsibility of accounts ms is to simply put a message into the RabbitMQ and with that, it can continue processing of the remaining business logic. That's exactly what happened, and we got an immediate response as can be confirmed from the postman console. This way, we have established the Async communication or event streaming ms's and my accounts ms has no clue about message ms. It is only aware about the message/event broker which is sitting in the middle and my RabbitMQ is doing all the magic behind the scenes. Now, before releasing the message service breakpoint, inside the accounts ms, we are able to see the log statements i.e., 'Sending Communication request for the details' and  'Is the Communication request successfully triggered ? : true' which confirms that as far as the accounts ms is concerned, it has done its part in processing the account creation request and sending the message to the RabbitMQ. That's why we are able to see a 201 response in the postman console. Now, under the message service console, as of now, there is no log details. Here if I try to release the breakpoint and resume execution you should be able to see are getting two new log statements which are 'Sending email with the details received..' and 'Sending sms with the details received'. With this slowed demo, you should have crisp clarity now. As a next step, we should also let our message ms to send a notification/an event to the accounts ms whenever it is done sending the email and sms to the end user. So, it is going to be a two way communication asyncronously. First, my accounts ms will trigger an event using which my message ms is going to send the communication. Maybe after 1 minute or two minutes or maybe in the worst case scenario also, after  1 day also, if my message is processed in the message ms, it should send a notification/event back to the accounts ms saying that I have processed communication successfully, please update the details on your side as well. That is what we will be implementing as a next step. Hope you are clear.
 * Do you remember slide number 172 titled 'What we are going to build using a pub/sub model'? As of now, we have only implemented steps 1 to 4. That means that the event streaming is happening from accounts to message service. As a next step, we should also try to stream an event from the message to accounts ms so that the business flow that we have is going to be complete. In order to send an event from message to accounts ms, we need to follow very similar kind of steps that we have discussed previously. As of now in the message ms application.yml file, we have a binding with the name 'emailsms-in-0' which is an input binding where my message ms will always keep looking/checking for a message inside a queue/channel with the name defined in the destination child property of the input binding i.e., 'send-communication'.group value i.e., 'message'. What if my message ms wants to stream an event to one of the exchange? We need to make very similar changes like we did inside accounts ms application.yml file. Which are, inside the accounts ms application.yml you can see we have created a binding of type output binding i.e., sendCommunication-out-0. Now inside message ms we will create an output binding i.e.,'emailsms-out-0'. Same drill, make sure your cloud function definitions is the prefix. What is the Spring cloud function definition in our case? Since inside our message ms application.yml file we tried to compose 2 function, then use that composed function definition as a prefix. Post that we need to mention'hyphen out' indincating that this is an output binding and finally 'hyphen 0' which is the starting index value that we need to follow as a standard. Now under the destination, I am going to mention a new destination which is going to act as an exchange inside my RabbitMQ. The destination name I am giving as 'communication-sent'. So this is the exchange name that will be created behind the scenes inside the RabbitMQ. With this, we should be done with all the changes inside the message ms to send an event to the channel/exchange/queue with the name 'communication-sent'. Now, you may have many question like, 'But you didn't make as many changes in message ms the same way you did inside accounts ms inside its AccountsServiceImpl.java class to send the message using this 'StreamBridge' bean reference by invoking its send behavior and passing the inputs i.e., 1. The output binding as the 1st parameter and 2. The message that you want to send. Interesting haha. We don't need to follow all these steps whenever we are suing Spring cloud stream functions. So that's one of the advantage that we have.
 *  So, behind the scenes, how it is going to work is, my spring cloud stream knows that an output from the function combination which is email and sms just as defined by composition inside the apllication.yml file of message ms, can be send as a message to the exchange/channel/queue with the name 'communication-sent'. What is the output from this emai|sms function? Whatever return type that we are going to return from the send function which sms. What is it? We are trying to return a Long data type which is customer account number. With this, my message ms is going to trigger a message with an account number value and using this account number value, my accounts ms is going to fetch the accounts details from the DB and is going to update the DB columns saying that communication is sent successfully for the account. Haha Did you see how much work we have avoided with the help of Spring cloud functions? beautiful!!! That's the beauty of Spring Cloud Functions and Spring Cloud Streams. Many people still use older approaches without using Spring Cloud Functions and Streams. I feel sad for them because they have to make pretty many changes whenever they have to migrate from one product to another product. The transition experience is snot going to be very seamless. Now, we have made all the required changes under message ms. As a next step we need to make changes under the accounts ms to accept the message that is sent by the message ms.
 * In the accounts ms, I am going to create a new package ie., functions. Here I am going to create a new java class i.e., AccountsFunctions. Here I am going to define a function that is responsible to accept the message(AccountNumenr) from the message ms and using that account number, I am going to fetch the account details from the DB and is going to update the DB columns saying that communication is sent successfully for the account. Check this class' docstring for more details. As a next step, we need to define some properties inside the application.yml file of accounts ms. We need to define some properties related to our function definition. So using the property spring.cloud.function.definition I can define my function definition which has the name/value of 'updateCommunication'. This should match with what you have just written inside the AccountsFunctions class. And btw, since we only have a single function, we need to mention the same single function only, and we don't have to have any requirements to compose multiple functions. That's why in our function definition in accounts ms application.yml file, we are not using any composition unlike what we did inside message ms application.yml file - Hope you can recall this. What if you had a requirement where you want to define multiple independent function definitions? In such scenarios, you can separate all your function definitions with a semicolon i.e., email;sms Like this both these 2 function definitions are going to work independently. Once you have defined the function details with this spring.cloud.function.definition property, the spring cloud stream project will automatically generate the input bindings and the output bindings based on the function names that you have defined - this you know and you visualized. So the function name that we have defined now is 'updateCommunication'. So using this function name we need to create an input binding i.e., updateComminication-in-0 because using input bindings we can always read messages from a queue/channel. So to define the queue/channel value, we will leverage the destination attribute so for this we will assign a name/value i.e., communication-sent. Next, using the group attribute we will give a value i.e., our application name. The reason we already know why. So that our queue name is not going to have is not going to have a randomly generated suffix value. Now with these changes we should be good.
 * Now, if you try to visualize the whole process, inside message service application.yml file, 1st we have defined an output binding i.e., 'emailsms-out-0' with the help of this output binding, the message is always going to be sent to the destination which is 'communication-sent' which is what we refer to as the exchange name. So how will the message come to this exchange? The return type of the sms function. This you know already. As soon as this communication-sent exchange receives the message, it is going to forward the request to the respective queue that we have configured for this exchange. That's how it works. Always make sure the destination value configured while defining an exchange for an output binding is the same as the destination value configured while defining a queue name for an input binding respective to that exchange. If you see the application.yml file of accounts ms you will see what I am talking about. easy! right?  Basically, this is how the spring cloud stream is going to establish the communication link between the 2 different services. And the format of your queue name is going to be destination.group this we already visualized in the RabbitMQ UI console. This should now be clear to you, next we wil see the demo of these changes.
 *
 *  Demo of Async communication or event streaming using Rabbit MQ pt.2
 *  ---------------------------------------------------------------------
 *  We will visualize the complete demo of asynchronous communication between accounts and message ms with the help of RabbitMQ. For the same make sure you have started your services i.e., RabbitMQ, configserver, eurekaserver, redis service, accountsdb service, accounts ms, message service, keycloakservice and finally gatewayserver service. Now, if I go to the rabbitMQ console under the exchanges tab, this time you should be able to see two exchanges i.e., send-communication and communication-sent. If you see an exchange like we saw previously i.e., emailsms-out-0, ignore it as it is an exchange that was created implicitly earlier before we had defined explicitly a destination for this output binding. This is when Spring Cloud Stream project was implicitly creating an output stream binding before we overrode that with our own binding configurations. If you start a fresh container of your RabbitMQ, you are not going to see this kind of implicit exchange because right now we have control on the exchanges being created for our functions by defining them inside the application.yml files of respective ms's explicitly. Now, under the tab queue and streams, you should be able to see two queue with the newest queue that we have create being;  'communication-sent.accounts'. For me I didn't see it, haha, find out why, instead I saw a randomly generated queue name i.e.,'updateCommunication-in-0.anonymous.g9UIFChWTsaOrpga__IELw'. I rectified this, haha, its because while defining your input binding, you hadn't followed the correct signature of defining an input binding i.e., functionname-in-0. In place of the functionname you had used the wrong value, but I rectified this to updateCommunication-in-0 and it worked . This is the queue where my accounts ms will keep looking/checking for messages from message ms. Now, lets leverage postman and try to test this entire flow. Under the collection gatewaserver_security invoke the request which is 'Accounts_POST_ClientCredentials', just modify the mobileNumber value and send the request and before that, make sure you have a new access token. But I know postman will take care of that as we have Auto-refresh token toggle on. On firiong the request I got a 201 Account created successfully and btw I received the response within 1 sec. But the breakpoint that I have put inside my message ms in the email function is stopped which simply means that the communication to the end-user is not completed. Now, if you go check the accounts table which is available inside the AccountsDB, here you should be able to see to see the new column that we added in this table i.e.,'communication_sw'. If you are using h2 db, you can access its's console against the accounts service port number i.e., lh:8080/h2-console and yoiu can veriufy all this that I am saying.
 *  As of now the 'communication_sw' nothing but the communication switch column has a null value for the account that we have just created. Now, as soon as I try to release the breakpoint that we have placed in the email function of message ms, the communication will be send to the end user  and my message ms is also going to stream an event/message to my accounts ms to update the status inside the accounts table. Now, if you refresh you accounts table, this time you should see that the communication switch for the account that we have just created is populated with the value true/1. This confirms to us that the entire flow is working asynchronously as discussed in details with the help of RabbitMQ. In the same process, we also set up event streaming ms's inside our get_tt_right-bank ms network. This way, whenever possible we need to make sure we are leveraging the event streaming capabilities inside our ms's as this will reduce the temporal coupling between our ms's. So far you should be clear with all the steps that we have followed. For your reference, I also mentioned all the steps in summary that we have followed in the slides which you can always quickly refer whenever you want to quickly refresh all the steps that we have discussed prior to an interview or a new project undertaking. As a next step, we need to test these changes inside the docker network as well. So make sure to generate the docker images for message as well as accounts services as that's where we have done the changes. Next we will be updating the docker-compose.yml file and using this we can try to start all our containers and test this scenario end to end.
 *
 *  Demo of Async comm or event streaming using Docker containers & Docker compose
 *  ---------------------------------------------------------------------------------
 *  To test the changes related to event driven microservices and RabbitMQ inside the docker environment, we have to create the latest docker images reflecting the changes we have done in accounts ms and message ms.
 *  Below are the changes that I have made inside the docker-compose.yml file:
 *  1. Added a RabbitMQ related service. Actually this was already present as we used it earlier in some other sessions. Actually you already know all the configurations, no need to discuss this. But you can check with the docker-compose.yml file comments on the services to remind yourself of what each configuration is.
 *  2. After adding this RabbitMQ related service, I went to accounts services related configurations and changed the tag name from v9 to v10.
 *    Also in this accounts service, I added the depends-on details as right now my accounts service is going to depend on rabbit service, that's why I am trying to convey this depends upon information
 *    Under the environment variables definition related configurations, I have created a new environment property with the name SPRING_RABBITMQ_HOST and we are assigning to its a value which is the service name of RabbitMQ service i.e., 'rabbit' that we have defined earlier on. This is the correct and MUST way because using this service name ONLY, the communication between the accounts and rabbit services is going to happen. Whereas other properties like RabbitMQ username, pwd, port number - no need to define them as I left them to be automatically the default values.
 *  3. At the end of the docker-compose.yml file(The 2nd last service), I have created a new service with the name 'message'. This is also going to depend on the rabbit service. Here I have also defined a new environment variable i.e., SPRING_RABBITMQ_HOST and its value I have given the service name which is 'rabbit'
 * As a next step, start all your containers with the help of docker-compose file by running the docker compose up -d command. Before that. Before I try to do this, make sure you have stopped all the running instances of your services inside the local system. as well as inside the docker desktop. Just stop, don't delete haha. Now you can run the docker-compose up -d command from the location of your docker-compose.yml file. For some reason if your laptop is not cooperating to start all these containers you can remove any unnecessary container configurations i.e., grafana related from the docker-compose.yml file since we are done discussing that. For me I am not removing anything as I am treating this as a prod ready thing. An alternative would be increasing the healthcheck timing configuration, especially the interval and the retries values.
 *
 * */
@Configuration
public class MessageFunctions {
    private static final Logger log = LoggerFactory.getLogger(MessageFunctions.class);

    @Bean
    public Function<AccountsMsgDto, AccountsMsgDto> email() {
        return accountsMsgDto -> {
            log.info("Sending email with the details received {}", accountsMsgDto.toString());
            return accountsMsgDto;
        };
    }

    @Bean
    public Function<AccountsMsgDto, Long> sms() {
        return accountsMsgDto -> {
            log.info("Sending sms with the details received {}", accountsMsgDto.toString());
            return accountsMsgDto.accountNumber();
        };
    }
}
