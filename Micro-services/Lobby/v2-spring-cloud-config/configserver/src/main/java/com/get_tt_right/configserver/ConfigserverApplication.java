package com.get_tt_right.configserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.config.server.EnableConfigServer;

/** Update as of 2/02/2025
-  As of now, inside our microservices network, we have 3 different microservices + a config server and we are able to read the properties from the config server during the startup of the respective microservices. Everything is working perfectly, and you may think that that is the end of the Spring Cloud config server, and we may not face any other challenges in terms of configuration management.
  We want to introduce a new problem that we may face inside the microservices environment in terms of configuration management. Think like, you have your config server set up all your microservices started and connected to the config server, and they have loaded the properties perfectly! All of a sudden, you want to change a certain property inside your config server and the same you want to be reflected
  at runtime in all the microservices without restarting them. This is a very common scenario that we may face in the real-time microservices' environment.
 You may have a question like, what is the problem that I have if I just restarted my microservices? The answer is, if you have a single microservice, then it is fine to restart the microservice, but if you have a large number of microservices running in the production environment, then it is not a good idea to restart all the microservices just to reflect a single property change.
 And also it is worth noting that inside microservices it is not only just one microservice, you may have 100s of them and there will be multiple instances of each microservice running in the production environment. So, if you want to restart all the instances of all the microservices, then it is a very manual and tedious task that someone has to do/take care of, and it is not a good idea to restart all the instances of all the microservices just to reflect a single property change.
 Whenever you bring some manual task(s) inside microservices then it is going to make your microservices setup very complex and that's why you should always be on the lookout for an option on refreshing the properties without restarting the microservices instances. Think like, for example you have a feature flag which you have configured inside your config server and so based on this feature flag/boolean flag you want to control the behavior of your microservice business logic. When
 the flag is disabled you want to execute some other piece of code. These type fo flags you want to change anytime inside the config server and you want the same to be reflected immediately inside your individual microservices without restarting them. This is a common scenario that projects will try to achieve inside there microservices network.

 How to refresh the configurations/properties inside the microservices without restarting the instances
 --------------------------------------------------------------------------------------------------------
 1. We need to make sure all our individual microservices have the Spring boot actuator dependency defined inside the pom.xml file.
 2. Go to our Dto classes where we are trying to hold all our property details
    Inside Accounts microservice, there is a Record class called AccountsContactInfoDto.java which holds all the properties that my microservice is going to read during the startup from the config server. With this set up using record class signature we have a problem.
      . Whenever we are using a Record class means, once the object of this AccountsContactInfoDto is created during the startup of the microservice, we cannot change the property values at runtime by invoking the setter method(s) of the object of this class.
        Reason: Whenever you are using a Record class all your fields are going to be final once the object is created with the help of constructor and thus no way to change the values inside the fields at runtime.
      That's why we need to modify this AccountsContactInfoDto class to a normal POJO class instead of a Record class. Also, mention the lombok annotations, @Getter and @Setter. Using these annotations only, my Spring boot framework is going to get and set the fields of this class at runtime.
      Do the very similar changes inside the LoansContactInfoDto.java file  and CardsContactInfoDto.java file. Like this, we will have made all the Dto classes changes of the respective microservices to allow our microservices be able to change the property values at runtime.
 3. Inside the application.yml file of accounts microservice, we need to enable the actuator Api path. By default, actuator is not going to expose all the management related API paths. That's why we need to specifically enable them. Now we want to mention the below property
     management - Since we want to enable the management related APIs. That's why we need to mention this at the root location.
     Under management, we have endpoints - Since we want to enable the endpoint(s) related to the management APIs. That's why we need to mention this under the management property.
     Under endpoints, we have web - Since we want to enable the web related endpoint(s) that are related to the management APIs.
     Under web, we have exposure - Since we want to expose the web related endpoint(s) that are related to the management APIs.
     Under exposure, we have include - Once you mention this include property,  we need to enable the actuator endpoint that will allow refreshing the properties at runtime.
       . Instead of mentioning the refresh API alone, this property could also take other values
 Instead of mentioning any value, we will mention asterisk (*) which is going to enable all the management related APIs. With this asterisk value, I am telling to my Spring boot actuator to enable and expose all the management endpoints supported by the Spring boot actuator.
 Inside these endpoints only we are going to have the refresh  related API/endpoint which is going to help us to refresh the properties at runtime.
 This same change we need to make inside loans and cards microservices application.yml files as well.
 With this, we have made all the relevant changes inside all our microservices. As a next step, lets try starting all our microservices starting with the config server and post that we can try to change a property at runtime inside the Git repository and see whether the same is getting reflected inside the individual microservices without restarting them.
 As of now inside accounts-prod.yml file, we have a property message with the value, "Welcome to EazyBank accounts related prod APIs ". Inside this message, we will replace, 'prod' with 'production'. But before doing this change first lets verify that our accounts microservice will read this message with the value, "Welcome to EazyBank accounts related prod APIs " during the startup.
 . Invoke the contact-info API of the accounts microservice  via postman and verify that the message is coming as, "Welcome to EazyBank accounts related prod APIs ".
   The same you can confirm for the loans and cards microservices as well.
 . Inside the GitHub repo if you make the change discussed above and commit the same, then the same will be reflected inside the individual microservices without restarting them.
  Do the same for the prod yml files of loans and cards microservices as well.
 - Before testing the contact-info API for the respective microservices, first lets see the config server behavior by invoking the http://localhost:8071/accounts/prod endpoint/API which is available inside the config server. Yeey! you should be able to see that the config server has the latest property value, "Welcome to EazyBank accounts related production APIs " instead of "Welcome to EazyBank accounts related prod APIs ".
   You can test the same for the loans and cards microservices as well. This confirms that whenever a microservice instance is trying to invoke respective API path of the config server during the startup, my config server is not going to rely on the local cache as it is always going to check with the master copy which is available inside the Git repository, and it is going to return the same latest values to the respective microservices.
 - This means that, there is no problem in refreshing the properties from the config server perspective. This we have confirmed by invoking the respective API paths of the config server. Now, the problem we have at hand is, our respective microservices should be able to read these latest values. We already know that microservices will only connect with the config server during the startup of the application. In order to reflect these latest properties, we need to restart the microservices instances.
   But we are trying to avoid this manual process because we already know that this is not a good idea to restart all the instances of all the microservices just to reflect a single property change.  Doing thi will impact the traffic, and it involves manual intervention. To overcome this challenge, like we said, Actuator is going to expose an API endpoint with the name refresh.
   If you go to accounts actuator. I.e., http://localhost:8080/actuator , against this endpoint you will see a list of all the management related APIs that are exposed by the Spring boot actuator. One of the API is refresh, Ctrl + F to find this API. This refresh API is going to help us to refresh the properties at runtime without restarting the microservices instances. If you click on that refresh API, you will see that it is going to return a 405 status code which means that this API is not allowed to be invoked by the GET method. This API is only allowed to be invoked by the POST method.
   As we know, from the browser always the Http methods will be invoked. Before that, if you invoke all the contact-info APIs of the respective microservices, you will see that the message is coming as, "Welcome to EazyBank accounts related prod APIs " instead of "Welcome to EazyBank accounts related production APIs " which is the latest value that we have inside the Git repository
   Now, we will try to invoke the refresh API of the accounts microservice. For that, we need to use the postman tool. Open the postman tool and create a new request. Inside the request, mention the URL as, http://localhost:8080/actuator/refresh and the method as POST. You can also get this as part of the postman collection, I have named it RefreshConfig.
   Since we are trying to refresh the config of accounts microservice we need to used the refresh endpoint URL of the accounts microservice instance like http://localhost:8080/actuator/refresh. By default, this URL ins never exposed inside your microservices but since we have mentioned the configuration property management.endpoints.web.exposure.include as *, it will be exposed along with all the other management related APIs.
 If you needed to expose only the refresh endpoint then your configuration property should be like management.endpoints.web.exposure.include=refresh. But we have mentioned *, so all the management related APIs are exposed and also in the coming sections we will be enabling many more other management endpoints.
 Now invoke the request, RefreshConfig,Inside the postman tool, click on the send button. You will see that you are getting a 200 OK status code as a response. This means that the refresh API is successfully invoked. You will get a 200 OK with the below response in the body
 [
 "config.client.version",
 "accounts.message"
 ]
 - This is nothing but telling us that accounts.message property is changed and the same is being refreshed behind the scenes. Apart from accounts.message, we are also getting the config.client.version property. This property you will always get it whenever you change something on the GitHub repo because whenever a change happens, your config server is going to change the version number behind the scenes and the same it is trying to send to the config clients like accounts microservice.
 - For us, we don't need to worry about config.client.version, we need to worry about the accounts.message property because it is one that is going to impact our business logic. Now, if you invoke the contact-info API of the accounts microservice, you will see that the message is coming as, "Welcome to EazyBank accounts related production APIs " which is the latest value that we have inside the Git repository. And please not that, we have not at anytime restarted the accounts microservice instance. This is how we can refresh the properties at runtime without restarting the microservices instances.
   This is so beautiful!! It means that we are able to change our property values at runtime without restarting our microservices instance.
 - Whatever we have discussed above, a very similar activity we have to do for loans and cards microservices as well.
  1. Initially, test the contact-info API of the respective microservices and verify that the message is coming as, "Welcome to EazyBank loans related prod APIs " and "Welcome to EazyBank cards related prod APIs " respectively. This is because even though we made some changes inside the Git repository, the same is not reflected inside the individual microservices. Reason, we have not invoked the RefreshConfig API request of the respective microservices.
  2. Invoke the RefreshConfig API request of the respective microservices and verify that you are getting a 200 OK status code as a response. This means that the refresh API is successfully invoked.
  3. Now, invoke the contact-info API of the respective microservices and verify that the message is coming as, "Welcome to EazyBank loans related production APIs " and "Welcome to EazyBank cards related production APIs " respectively. Hurreey! everything worked as expected.
 *  Like this you should be clear on how we can refresh our property values at runtime with the help of actuator refresh endpoint without restarting the microservices instances.
 * For a quick recap on the steps that we followed, you can check with the slides as everything is mentioned there. So far, whatever we have discussed is super perfect but there is a serious drawback with that.
 * Think like, you have 100s of microservices each having 5 instances, which means there will be a total of 500 instances running inside your production. For some reason, if you are trying to change a property in all the microservices then you need to invoke the refresh endpoint against all the 500 instances running inside your production. This is a very manual and tedious task that someone has to do/take care of. This is not a good idea to invoke the refresh endpoint against all the 500 instances running inside your production.
 * Some operations team or some platforms team they will try to automate this process by writing some scripts inside the CI/CD pipelines or they will try to write Jenkins jobs  or CI/CD jobs which will invoke all the refresh endpoints against all the 500 instances running inside your production. But still this may not be a convenient solution for many projects. That's why lets try to explore this further and try to identify if we have any better option to refresh the properties dynamically without invoking the refresh endpoint against all the 500 instances running inside your production.
 * Previously, we discussed that inside microservices network, ' The more responsibilities you take, you get more power from your microservices applications' . Right now, we set up our microservices with a config server but the problem that we are facing is, we have to invoke the refresh endpoint for each running microservice instance whenever we are trying to refresh the configurations at runtime without restart. If you want to avoid this, then definitely your organization or you, should be ready to accept more responsibilities. So, to overcome this challenge, we have to use a new project inside the Spring Cloud which is called Spring Cloud Bus.
 * You can check its documentation - https://spring.io/projects/spring-cloud-bus. In the overview tab, you can see that, " The Spring Cloud Bus links all the nodes of a distributed system with a lightweight message broker and this can be used to broadcast the state changes (For example, Configuration changes) or any other management instructions. " So, whenever you are using this Spring Cloud Bus, behind the scenes, this Spring Cloud Bus is going to interlink all your microservices instances with a lightweight message broker like, RabbitMQ or Kafka. With this, the advantage is, you need to invoke a bus refresh api path available against your actuator only one time for one
 * of the instances. If there are 500 instances running inside your production, you don't have to invoke the actuator refresh api for all your 500 instances. Instead, you can simply invoke bus refresh api for any of the instances inside this total 500 instances. With that the Spring Cloud bus will take care of communicating the changes that happened inside the Spring Cloud config server to all other node/instances connected to the same message broker like RabbitMQ or Kafka. To get started with this approach, first we have to have a RabbitMQ broker running inside our local environment/system. Visit the RabbitMQ website - https://www.rabbitmq.com/
 * 1. To get Started >> Click on the Get Started button. >> Click on the 'installation guide' link >> The very fast and the easiest option that we can follow is by running the docker run command that you will see on that page. When you run that command the RabbitMQ message broker is going to run inside your local as a docker container. Link this you are reaping the fruits as a result of the power of Docker. Without Docker, you have to download the RabbitMQ broker >> Install >> Start the RabbitMQ broker. All this manually! With the help of Docker, we will avoid all those installation steps.
 * Whenever you are trying to set up RabbitMQ behind the scenes it is going to install 2 components. 1. A management Component which is responsible to manage your RabbitMQ and provide the UI to the RabbitMQ 2. The core component which is going to handle all the Message Queue related functionality. On executing the command, on the very same terminal that you executed the docker run command, the RabbitMQ will start. In our workspace, inside the pom.xml of all the microservices including the config server, we have to add a dependency related to the Spring Cloud Bus and RabbitMQ i.e., spring-cloud-starter-bus-amqp. With this, we are trying to set up both Spring Cloud Starter Bus and Message Queue with RabbitMQ integration.
 * 2. As a next step, we need to make sure we are enabling the actuator API path which is 'bus refresh' inside all our microservices instances. As of now if you open the application.yml file of accounts microservice or any other microservice, we have mentioned a property to expose all type of management endpoint using the property 'management.endpoints.web.exposure.include'. We have mentioned the value as *, which means that all the management related APIs are going to be exposed. So, we don't need to make any changes to that since we have mentioned its value as *. This will enable and expose 'refresh' path, 'bus refresh' path and any other endpoints/paths available inside the actuator. This same property we have mentioned
 * inside the loans and cards microservices application.yml files as well. So, we should be good from this property perspective.
 * 3. We need to provide the connection details of the RabbitMQ broker inside the individual microservices instances. We have all the set-up needed, and we also started the RabbitMQ, but we need to establish a link between the microservices and the message Queue by providing the connection details of the RabbitMQ. For the same, inside the application.yml file of each microservice, we need to mention the property under the Spring parent element which is: spring.rabbitmq.host = "localhost" followed by what the port number of the RabbitMQ broker. For example: spring.rabbitmq.port = "5672". After the port we should pass the username which by default is guest and the password which by default is guest. With these properties, we should be good.
 *    And btw, as a fun fact, even if you don't mention these default properties of step 3 still the connection will be established because these are the default values where my RabbitMQ is going to be started just like I didn't specify this for the config server. Spring boot is smart enough to consider the default values to connect with the RabbitMQ. But I just mentioned them for your information inside accounts, loans as well as cards microservices application.yml files. In case inside your project you are using values other than the defaults. i.e., different port number, username and password then it is mandatory to mention this property in all your microservices including the config server. Like this, we have made all the required changes. As a next step, stop all your microservices instances and then on the RHS nav of intelliJ click the maven icon and then the symbol to refresh/load all the maven changes as we added new dependencies like spring-cloud-starter-bus-amqp.
 *    We need to make sure we are doing a clean build so that all the required dependencies will be downloaded. And this is what will happen when you click on the load/refresh icon.
 * 4. Now, start you config-server, followed by the other microservices. Next, in the GitHub repository prod yml files for accounts, cards and loans microservices, change the property message from  "Welcome to EazyBank xxx related production APIs " back to  "Welcome to EazyBank xxx related prod APIs ". As of now all our microservices started with the value of message being  "Welcome to EazyBank cards related production APIs ". We can test and verify the same by randomly testing the contact-ifo endpoint for either accounts/loans/cards microservices. Yes!! working as expected.
 *    For the changes we have just done in the GitHub repo, we can try to validate is our config server is able to read these latest values by invoking the respective config server endpoints that fetches properties for respective microservices. For example, accounts microservice - http://localhost:8071/accounts/prod. And yes!! everything is working as expected as config server refreshed all the updated properties without any restart.
 * 5. Now, as a next step, we need to invoke the Bus Refresh API endpoint inside any of the microservices instances running. Under accounts folder in the postman collection, we have a request with the name 'BusRefresh'. Open your eyes! on clicking the send button, it is worth noting that the invocation is happening using the accounts microservices instance - http://localhost:8080/actuator/busrefresh. But before trying to invoke this, if you invoke the contact-info API for cards as well as loans, you will see the message property has the 'production' string as part of it. But after invoking the busrefresh endpoint on top of the accounts microservice instance, if you invoke the contact-info endpoint for either of the 3 microservices, then you should see the message property has the string 'prod'
 *   . On invoking the busrefresh endpoint, you should get a successful message with the response code '204 No Content' just as expected. The server successfully processed the request, but it is not returning any content and that's why we are getting a 204 response code.
 *     Behind the scenes, my Spring cloud bus, since it detected a change happened on the config server version, it will communicate the same to all the microservices instances that are registered with the RabbitMQ. Since the loans and cards microservices are also registered with the RabbitMQ, the change will be communicated to them as well, and they will refresh the properties without the restart of the application and without invoking this busrefresh or refresh endpoints.
 *     You can confirm the same by invoking the contact-info API for accounts/cards/loans and yes!! some super magic happened, and we are getting the message property having a string 'prod' and not 'production'. This confirms to us that we are able to refresh the properties at runtime by invoking the busrefresh against ONLY! 1 of the running microservice instances. We don't have to invoke the busrefresh API path or refresh API path available against all your running microservices instances. We simply need to invoke the busrefresh against ONLY one of the running instances but the CONDITION IS, ALL the remaining instnaces should be registered to the same message queue which is RabbitMQ in our scenario.
 * Summery of the changes and steps that we have achieved:
 * -------------------------------------------------------------
 * - Check the slide for reference.
 * Refresh configurations at runtime using Spring Cloud Bus and Spring Cloud Config Monitor
 * ---------------------------------------------------------------------------------------
 * 1. As of now, inside our microservices network, we are able to refresh configurations/properties runtime without restarting our microservices instances by invoking the refresh/busrefresh API paths available inside the actuator. Even though leveraging the busrefresh API path is a better option than the refresh API path, still both of them have manual approach involved as we discussed in details. Someone has to invoke the busrefresh endpoint on either of the one running microservice instance or refresh endpoint on all the running microservices instances. Now, we are looking for an automated approach which will automate the refreshing of the properties without invoking any API paths manually.
 *   For the same, we have an option with the help of GitHub Webhooks. This approach is build on top of the Spring Cloud Bus approach that we have discussed in the previous section. So, all whatever changes that we have discussed up to now have to be there to use this approach as well . To get started with the new approach we need to add the spring-cloud-config-monitor dependency inside the pom.xml file of the config server. DON'T ADD IT IN OTHER MICROSERVICES APPLICATION.YML FILES!! Whenever we add this dependency inside the config server, it is going to expose a new API path with the name '/monitor'. IT IS WORTH NOTING THAT THIS IS NOT AN API PATH UNDER THE ACTUATOR! This is a REST API path which is exposed by the Spring Cloud Config Server ONLY!
 *   Using this Api path available inside the Spring Cloud Config Server, we can create a webhook inside the GitHub repo saying that, whenever a change happens inside my GitHub repo, like a new property is added, please invoke the monitor API path. As soon as this monitor Api path receives a webhook request from the GitHub repo, behind the scenes, it is going to invoke a refresh event with the help of Spring Cloud Bus and RabbiyMQ. That's the high level introduction of what is going to be happening.
 * 2. As a next step, inside the application.yml file of the config server, we need to make sure we are mentioning the endpoint 'management.endpoints.web.exposure.include' with the value as '*' . Because, like I said, whenever the GitHub repo sends a webhook request to the monitor api, behind the scenes, my config server is going to use the Spring Cloud Bus. That's why since behind the scenes it is going to automatically invoke the busrefresh endpoint, we need to make sure we are enabling the bus-refresh management endpoint inside the config server as well. We enabled all the management endpoints actually by mentioning the value to this property as '*'.
 * 3. As an next step, mention the RabbitMQ configuration details just to be consistent with all the microservices. Previously we said that it is completely optional because as of now, we are starting our RabbitMQ with the default values.
 * 4. Create a WebHook in the GitHub Repo where we are maintaining all the properties of the microservices >> Under this GitHub repo you should be able to see a settings tab just above >>  on the LHS nav, click on the webhook link that we have >> Post that, on the top RHS, click the Add Webhook button. The purpose of webhook whenever there is a change happens inside your GitHub repo, GitHub is going to publish an event to the URL that you will have configured. All this will happen automatically whenever you try to push a new change. Webhooks are very famous and are available in most of the Git implementation products like GitLab, Bitbucket, etc. Regardless of whatever Versioning system you are using you can easily create a webhook(s).
 *   .Under the 'Payload Url' label, you have to mention the URL where the webhook request is going to be sent by my GitHub repo. For this I am giving the URL as http://localhost:8071/monitor. This is the API path which is exposed by the Spring Cloud Config Server which my GitHub can invoke. Do you think this is going to work? Definitely not! Because, we are trying to give a localhost URL and by this, how will the GitHub server know where this URL is deployed! I have not given any public IP, not even any domain name. Like this GitHub server will be clueless and will eventually fail!
 *     - In a production scenario, the operations team will configure a Public IP or Domain name in the place of localhost. But now, how to overcome this challenge? To help in these kind of scenarios, we can explore a website option - hoodeck.com. You could explore other options as well. hookdeck.com is website which will help us in testing the webhooks even with the localhost system. As of now, the GitHub server is not able to send a hook to our local system but with the help of this mediator website, we can happily resolve that challange. To understand how to go about this, Navigate to 'Developers' menu >> Click on the link 'Hookdeck console' under the 'Sdk & Tools' section >> At the top of the page, you can see a link ' Add Destination' which on clicking we have to add the destination details >> You will see a set of instructions that you need to follow on the RHS of the page under a tab like 'localhost'
 *       The very first instruction is to install the hookdeck related libraries inside my local system >> Login into the session as part of step 2 from our localhost system - You will get a hoodeck login command as part of this step on the same website as an instruction >> As soon as you run the command in step 2, my local hookdeck CLI will be configured with my remote console sandbox. As part of this step 2, we need to run another command i.e., hookdeck listen [port] Source, nothing but a hookdeck listen command. Make sure to provide the port number where your localhost is trying to listen. In our scenario, the config server is started at the port 8071 . So run the command as, hookdeck listen 8071 Source
 *       If the login command is executed multiple times, it may result into a 401 error. To resolve this, run the 'hookdeck logout' command followed by the 'hookdeck login' command.  Then on running the hookdeck listen command, you will be asked what is the path hookdeck has to redirect the request received from the GitHub repo webhook. Yes!, like we know the path is http://localhost:8071/monitor. Mention this as '/monitor'. If not asking for the forwarded path, run the command as, hookdeck listen 8071 source --cli-path /monitor. When running this command, you don't have to provide the hostname(localhost) specifically. It it asked for the connection label, our hostname in this case, give that as 'localhost'.
 *       You should be able to see that a new session will be created for you. You should be able to see under the 'source' a webhook URL  which has some domain name i.e., source URL: https://hkdk.events/rrto11afrn49v4. This URL will perfectly work inside the GitHub repo. Whenever a webhook request is received from the GitHub repo to this webhook URL - source URL: https://hkdk.events/rrto11afrn49v4, it is going to redirect that into my local system to the path monitor as can be seen from the 'connections' section in your PowerShell.  Copy this web hook URL, source URL: https://hkdk.events/rrto11afrn49v4, you can see that it has 'https' in it. This is what you need to mention inside your GitHub repo webhook settings under the label 'Payload URL'.
 *    . Under the 'content type' label, mention the value as 'application/json'.
 *    . Under the secret, since we have no secret involved in our scenario, just leave it blank.
 *    Next, under the section 'Which events would you like to trigger this webhook?' I want the webhook to be created/triggered only in the case of push event and so select the radio button ' Just the push event.' This means nothing but whenever I make some changes. I don;t want in any other scenarios like, Whenever a pull is happening or whenever a new branch is created ..etc All such events I want to ignore as I am only interested with the push event.
 *    Post that, you can now click on this 'Add webhook' button. This will create a new webhook inside your GitHub repo.
 * - Back into my workspace, start all the microservices starting with the config server. In the GitHub repo change the message property value from 'Welcome to EazyBank xxx related prod APIs ' to 'Welcome to EazyBank xxx related webhook APIs '. This I just did for fun. for all the xxx_prod.yml files. xxx stand for the 3 microservices accounts, cards and loans. >> Before trying to commit the change for each xxx_prod.yml file, I am first going to invoke the config server xxx API path http://localhost:8071/xxx/prod, and I will get the message property having a value 'Welcome to EazyBank xxx related prod APIs '. Also invoke the contact-info API path for each xxx  microservice http://localhost:port/contact-info/, and you should see the message property having a value 'Welcome to EazyBank xxx related prod APIs '.
 *   Ready to see the magic, on committing the change for each xxx_prod.yml file and repeating the process to invoke the xxx API path and contact-info API path, I will get the message property having a value 'Welcome to EazyBank xxx related webhook APIs '. This is a clear indication that a push event has been triggered by the GitHub repo webhook that we created. To visualize this, navigate to the Settings tab >> Webhooks >> Click on the webhook link >> Click on the Recent Deliveries tab >> You can see that the very first time a ping happened to to test whether the hook is working or not >> Post that you will see a push event happened by my GitHub >> If you open that push event you will be able to see all the details about what file is changed. If you scroll down in the payload section you can see that under the 'repository' key  then under the 'full-name' key you will see a value i.e., 'Colince-Temoi/configs' which indicates that under that GitHub repo there is a change that happened.
 *   You should also be able to see lot more details under the payload section. If you search for eaxmple for 'accounts' string - Okay I am searching this because this is where we have made a change first and pushed that. You should be able to see the commit information like, commit 'id' commit 'message'...etc At the same time under the 'modified' list we have the modified file which is "accounts-prod.yml".  As of now, we have not invoked any busrefresh or even refresh API path. If you go to the Powershell terminal or whtever terminal window you used to set up the hookdeck stuff . There you can see an Error as a first thing, which nothing but means that initially when a ping request came, by that time we had not started the config server. But after we tried to make the change in the GitHub repo, a new webhook request came and by that time we had started the config server and that's why we are able to see the request is a green with 200 status code.
 *   2025-02-08 10:34:25 [200] POST http://localhost:8071/monitor | https://dashboard.hookdeck.com/cli/events/evt_aLyQwmkEVoJKkJ7nSs
 *   Like there is a POST request which happened to the API path http://localhost:8071/monitor from the console session - https://dashboard.hookdeck.com/cli/events/evt_aLyQwmkEVoJKkJ7nSs - of the hookdeck console session of the hookdeck that we have created. Now, first lets try to test the config server response for the endpoint http://localhost:8071/xxx/prod. You should be able to see the message property having a value 'Welcome to EazyBank xxx related webhook APIs '. Actually this is not the magic as we've seen even before the Webhook concepts this was happening like this. The real magic is what we will see in when invoking the contact-info API path http://localhost:port/contact-info/ for the xxx microservice. Hurreeey! You should be able to see the message property having a value 'Welcome to EazyBank xxx related webhook APIs '. This should bring a lot of happiness because we did a lot of hardwork and took a lot of discussion around this. All these are production ready scenarios.
 *   If you are seriously working inside any production application, all these are the approaches that you need to follow. That's why NEVER go with the 'Hello World'/'Simple Approaches' haha! Please use this better option.
 *  - We have taken responsibilities like running a RabbitMQ, creating a Webhook insid ethe GitHub repo. Like this, if you take more responsibilities, the microservice is going to give more powers to you! If you want to re see this magic again, inside the GitHub xxx_prod.yml file, change the message property value from 'Welcome to EazyBank xxx related webhook APIs ' to 'Welcome to EazyBank xxx related prod APIs '. As soon as you commit, inside the Powershell console you should be able to see that a webhook request was fired with a 200 status code. Now if you invoke the endpoint http://localhost:port/contact-info/ for the xxx microservice, you should be able to see the message property having a value 'Welcome to EazyBank xxx related prod APIs '.
 *  - With this everything should now be clear to you. In the slides you can see a summery of the steps that we have followed to achieve all this beautiful concept!
 * For more details, refer with this doc string on GitHub where I have commited the changes with the message, 'Refresh Configurations at runtime using Spring Cloud Bus and Spring Cloud Config Monitor with a touch of WebHooks magic'.
 * */
@SpringBootApplication
@EnableConfigServer // To enable th config server functionality
public class ConfigserverApplication {

	public static void main(String[] args) {
		SpringApplication.run(ConfigserverApplication.class, args);
	}

}
