package com.get_tt_right.eurekaserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

/** Update as of 11/3/2025
 * In this session, we will try to start 2 instances of loans ms and see the client-side load balancing in action. As of now, we tested the Eureka related changes with only one instance of loans and cards ms, and you may have a question like, how is the load balancing working?  I am not able to see the load balancing demo because I am using only one instance! Don't worry. Let us see that with 2 instances of loans ms. In order to create 2 instances of loans ms, I just need to make a copy of the existing definition inside the docker-compose file.
 *  Inside the docker-compose file, we need to make sure that the service names are distinct because each will act as a separate container. For the new service you can give it the name, loans1. After changing the service name, we should also change the container name because this should also be unique, so I will just make it as loans-ms1. Also, the port that we are trying to expose to the localhost or the outside world, we need to make sure we are using a different port, otherwise we will get a port conflict error. Up to now we should be good. You can now go ahead and run the docker compose up -d command.
 *  It may take some good amount of time because, since inside our local system we are trying to create many containers, it maybe very slow. If you visit the docker dashboard just immediately after firing the docker compose up -d command, you will see some metrics regarding CPU and memory usage. You will see by default how many cores are allocated to your docker server as well as the memory. As we try to create many number of containers, you should be able to see a higher CPU and memory usage. That's why inside the docker-compose.yml file I have just created 2 instances of loans ms. You can also create one more instance of cards ms as well. But even without creating one more instance of cards ms, we should easily be able to see the demo of client side load balancing.
 *  Meanwhile, you can refresh your eureka dashboard and see if the ms's instances are getting started and registered with the eureka server successfully. In this dashboard, you should see we have Loans ms having 2 instances started and registered inside the eureka server. That's why under the column labelled AMIs you should be able to see (2) for the loans ms row. If you try to access the URL localhost:8070/eureka/apps, inside this, you should be able to see all the instances details. Under loans, you can see there are 2 instance details whereas under the other ms's we only have one instance. This confirms that multiple instances of a ms are registering with the Eureka Server. Now, lets try to test the client-side load balancing.
 *  To test the changes, 1st I am going to create the data using the CREATE APIs for accounts, cards as well as loans. If you may notice, while creating the loans details using the same mobile number by using the port 8090, with this since we are using separate H2 databases for each instance, whenever loan details that we have just created will be available in only one of the instances H2 DB but not in the other instance. Whereas in the real prod applications since we are going to use MySQL or any other DB for all instances of Loans Ms, the data will be accessible for all loans instances ms's from a single DB designated for Loans. But I decided to use H2 DB so that you can easily visualize Client-Side load balancing in action. So, intentionally I will not do a CREATE loans details with the loans instance exposed to the outside world/localhost via the port 8091.
 *  So that, whenever we are trying to test the fetch customer details API, sometimes we will get a successful response i.e.,(Loans information along with other customer related information) and the other times we are going to get an exception saying that there are no loan details for the given mobile number. So, sometimes you will see that the request will hit the loans instance where we have saved the loans details i.e., 8090, and sometimes it will go to the loans instance where we have not saved the loans details i.e., 8091 and that's why you will face an error like, 'Loan not found with the given input data ...." This clear tells you that behind the scenes some load balancing is happening at the Accounts Service level itself by leveraging all the service registry details that is shared by the Eureka Server and here OpenFeign client library is playing a very important role.
 * With this demo, you should have crisp clarity about Client-Side Load balancing. Later, we will also discuss server side service discovery and load balancing when we try to deploy our microservices inside the K8s environment.
 * And that was it about the foundations around Service Discovery, Service Registration and Load balancing.
 * */
@SpringBootApplication
@EnableEurekaServer
public class EurekaserverApplication {

	public static void main(String[] args) {
		SpringApplication.run(EurekaserverApplication.class, args);
	}

}
