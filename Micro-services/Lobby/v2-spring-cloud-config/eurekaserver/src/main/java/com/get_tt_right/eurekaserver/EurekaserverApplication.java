package com.get_tt_right.eurekaserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

/** Update as of 1/3/2025
 * On top of this class, you need to mention an annotation: @EnableEurekaServer => Using this annotation, we are trying tgo convert a normal Spring boot project to act as a service discovery agent with the help of eureka libraries present in the Spring Cloud Netflix project.
 * As a next step, open the application.yml file and rename it to application.yml file so that we can try to provide the configurations with the yml format. We will mention the below properties:
 * 1. Config Server details - So that my eureka server can connect to the config server during the startup process and try to fetch the properties related to eureka server.
 *   - You can open any of the application.yml files of other microservices and get these details. spring.config.import=optional:configserver:http://localhost:8071
 * 2. Actuator related details - To help us enable the liveness and readiness of the eureka server. Reason: Later on inside the docker-compose file we will have to configure a policy that eureka server is started before accounts, cards and loans ms are started since they have a dependency on eureka server.
 *    Since they have a dependency on the eureka server, I will need to define the healthcheck details inside my docker-compose file. Whenever we want to define health-check details, we need to make sure that we are exposing the readiness and liveness details. We already mentioned these properties inside the configserver application.yml file. So, copy all those actuator related details from the configserver application.yml file to the eurekaserver application.yml file.
 *    You can see that management related endpoints, I am exposing everything i.e., *  After that, I am trying to enable health related urls including with readiness state and liveness state. With this, I have added all the required properties inside the eurekaserver application.yml file.
 * The remaining set of properties I am going to maintain inside the configserver. Inside the GitHub repository i.e., "configs" where we are maintaining al the configurations related to microservices Here you can see that I have uploaded a .yml file with the name eurekaserver.yml. You amy not see other property files for eurekaserver related to i.e., eurekaserver-prod.yml or eurekaserver-qa.yml. Reason: My Eureka server is going to behave/work in a very similar way across all the environments/profiles like default, qa and prod. This is since my eurekaserver does not have any dependency on db credentials or any other business logic where its has to behave/work differently based upon different environments/profiles.
 * This is the main reason we are maintaining the single file like eurekaserver.yml file. And please make sure, the same 'eurekaserver' prefix is same as the 'eurekaserver' spring.application.name property inside the eurekaserver application.yml file. You can always copy that property and doe a search on the GitHub repository i.e., configs to make sure that you get the same 'eurekaserver' prefix. Now lets try to understand the properties that I have given one by one.
 * 1. server.port=8070 => This is pretty clear. We want our Eureka server to get started at the port 8070.
 * 2. 'eureka' parent element. This is the root element. We need to define the properties inside this element.
 *    - Under this, I have mentioned 'instance'  then under this, 'hostname'. To this I am assigning the value 'localhost'. With this, I am telling to the eurekaserver what host name it has to consider. And of course by 'localhost' it obviously means inside our local machine/system.
 *    - Under 'eureka' again, I have mentioned 'client' with the below further child properties:
 *      . 'fetchRegistry=false' => By default it is true. I am setting it as false the reason being that, I don't want my eurekaserver to fetch the registry details of other microservices because it is never going to call any backing service/microservice(s). That's why it is unessesary to fetch the registry details of the microservices/backing services in our microservice network here. We can do that in the accounts, cards and loans microservices but not here. That's why in our individual microservices like accounts, cards and loans I am setting this property as true which is the default behavior.
 *         Since I want to change the default behavior here, I am setting the property as false.
 *      . 'registerWithEureka=false' => I am setting this property as false because I don't want my eurekaserver to register with the eureka server. That's why I am setting it as false. Its like telling eurekaserver, "Don't register with yourself and don't expose your details into the registry of the Service Dicovery. Since we don't want our eurekaserver to register with itself, I am setting this property as false.
 *      . 'serviceUrl' => Under this property, I have provided the below details:
 *         +. 'defaultZone' => To this I have mentioned the property which is the url where my eurekaserver is going to expose its functionality and other ms's can try to connect/register their details or to discover other service details. I have assigned a value like: http://${eureka.instance.hostname}:${server.port}/eureka/
 * - With these properties, now during the start-up process, my eureka server is going to connect with the configserver and fetch all these properties and then it is going to start those eureka related configurations.
 * - Now, we have made all the required changes inside the eurekaserver. To test this 'eurekaserver' if it is started properly or not, I can first start my configserver and then I can start the eurekaserver because my eurekaserver has a dependency on the configserver.
 *  . Once the configserver is started, we can confirm if it has loaded all the eureka related properties or not by invoking the endpoint: http://localhost:8071/eurekaserver(ApplicationName)/default(Profile). And yes!! you should be able to see all the properties that we have defined are loaded by the configserver.
 *    Now, you can start the eurekaserver in debug mode. You can locate the main class and run it in debug mode. And you can see that the eurekaserver is started properly. If you see the logs, "Fetching config from server at : http://localhost:8071" you can see that I tried to connect with the config server at the port 8071 and loaded all the default properties  and that's why it has started at the port 8070 which we have defined inside the eurekaserver.yml file that we have inside our GitHub repository i.e., configs.
 * - Now, to validate if my eureka server started properly or not, I am going to access a path which is "localhost:8070/" => This is the root path. As soon as I access this, you should be able to see a Eureka dashboard provided by Spring Eureka itself. We have not made any code changes to build this UI page but still we are able to access it. The purpose of this Eureka dashboard is, once the other microservices started registering there address details + metadata details with the eureka server, we should be able to see all those details inside this dashboard.
 *   As of now, it is currently empty. There are no, 'Instances currently registered with Eureka' because as of now, we have not established a link between other microservices to Eureka server. But this is a good start and confirms that our Eureka setup is successful. All the steps we have clearly seen above are now completed. For your reference, I have mentioned a summary of these steps below in the slides, you can always check that out. The next step obviously is to establish as link between our individual microservices with the service discovery agent i.e., eureka server.
 *
 * establish as link between our individual microservices with the service discovery agent i.e., eureka server.
 * ------------------------------------------------------------------------------------------------------------
 * - We have our Eureka server ready and running, now, lets make the necessary changes in our individual microservices to establish a link between them and the eureka server. Below are a discussion of the changes we need to make:
 * - With the changes that we are going to make, our individual microservices during the startup process, they are going to register with the eureka server and at the same time, they are also going to send the heartbeats regularly at a particular interval (Default one is 30 seconds).
 * 1. Add the dependency related to the Eureka Client
 *  - Go to 'start.spring.io' and search for the 'eureka'. Select the 'Eureka Discovery Client' and click the 'Explore' button. Then locate the dependency: spring-cloud-starter-netflix-eureka-client. Add this dependency to your pom.xml file.
 * 2. We now need to add the below set of properties inside the application.yml file of our individual microservices:
 *  2.1 Eureka related properties
 *    . Like what is the URL to my Eureka Server to which my Accounts|Cards|Loans microservices are going to connect to.
 *    . Most of the properties are going to be very similar to what we have mentioned inside the eurekaserver.yml file related to Eureka properties. The values to the keys is what we are going to modify to some of those properties. So, just copy and paste them from the eurekaserver.yml file and modify the values as discussed below:
 *     -> As value to 'fetchRegistry' => true to make sure that we fetch the registry details of other microservices.
 *     -> As value to 'registerWithEureka' => true to make sure that we register with the eureka server.
 *     -> As value to 'eureka.client.serviceUrl.defaultZone' => http://localhost:8070/eureka
 *     -> We don't need to mention 'eureka.instance.hostname'  as this is not a Eureka Server but a Client Microservice which will be connecting with the Eureka Server. That's the reason we don't need to mention this key.
 *     -> After removing that property, we need to mention a new property here i.e., 'eureka.instance.preferIpAddress' => true. The reason for setting this as true is: Whenever my accounts|cards|loans microservice is trying to register with the Eureka Server, by default it is going to register with the hostname. The hostnames will make sense whenever you are trying to use DNS mappings inside your microservices network. But inside our local system, we don't have any DNS mappings setup, so we need to mention this 'preferIpAddress' property as true so that my accounts|cards|loans microservice is going to register with the Eureka Server by using the IP address.
 *        So, behind the scenes, whenever my other/client microservices are trying to connect for example with the accounts microservice, my Eureka Server is going share the IP details of the accounts microservice with other microservices so that the other ms's can connect with the accounts ms. That's the purpose of this property.
 *     -> After adding the above-mentioned properties, we need to restart our accounts|cards|loans microservices. Like this, they should happily connect with the Eureka Server and register with it.
 *  2.2 We need to add other set of properties related to the 'Actuator' as well as 'info'. Let's try to understand and discuss what they are:
 *    2.2.1 Info related properties
 *      -> We need to add the below properties to our application.yml file:
 *        - Under the 'info' parent element, I am going to mention one more element which is 'app' under which I am going to mention:
 *          . 'name' to which I am going to assign the value 'accounts' because this is the name of our accounts' microservice.
 *          . 'description' to which I am going to assign the value 'Eazy Bank Accounts SApplication'. It is just a description that we are trying to use to explain about this microservice.
 *          . 'version' to which I am going to assign the value '1.0.0'.
 *         The reason as to why we are adding this info related information is: The same information we can see inside the Eureka Dashboard because there will be multiple ms's that will be registered with the 'Eureka' dashboard. So, If you want to know some details about those ms's, you can see them inside the Eureka Dashboard. This is why this 'info' related configurations will be very useful.
 *         When we will be seeing this visually in the Eureka Dashboard, then everything is going to make sense to you on how this info related configurations are getting displayed. And btw, this 'info' related configurations will be exposed as part of 'actuator' endpoint URL.  And by default, the 'info' related actuator endpoint is not enabled so we need to explicitly enable it.
 *    2.2.2 Actuator related properties
 *       -> To enable the 'info' related actuator endpoint, we need to add the below properties to our application.yml file:
 *         - Under the 'management' parent element, I am going to mention one more element which is 'info' under which I am going to mention:
 *            . 'env' under which I am going to mention: 'enable' to which I am going to assign the value 'true'.
 *        This is nothing but saying, " I am trying to enable the environment 'info' related information with the help of this property'.
 *   2.2.3 Properties related to the shut-down
 *      -> Like we said before, whenever the accounts ms is trying to shut-down, it will de-register it's details from the eureka server. That's why we need to add the below properties to our application.yml file:
 *        - For this, I need to enable an actuator URL which will allow me to shut down the accounts ms gracefully.
 *        - Under the 'management' parent element, I am going to mention one more element which is 'endpoint'(Singular form) under which I am going to mention: 'shutdown' under which I am going to mention: 'enabled' to which I am going to assign the value 'true'. This seems to be deprecated. You can always in future find the enhanced configurations for this property configuration.
 *          Once we enable this shut down related endpoint , we should also expose the shut-down related APIs by mentioning a new property at the root location  i.e., 'endpoints' under which I am going to mention: 'shutdown' under which I am going to mention: 'enabled' to which I am going to assign the value 'true'
 *           NOTE: This 'endpoints' configuration element is very different from the 'endpoints' element that is mentioned under the 'management' parent element. This should be at the starting/root position.
 * Now we have made all the required changes, save them and start your accounts ms but please note that before you try to start your accounts ms please make sure configserver and Eureka server are started. Now you should see that 'accounts' ms started successfully at the port 8080. It is also during the process registering itself with the Eureka Server. That's why you are able to see a log like: " DiscoveryClient_ACCOUNTS/DESKTOP-CR6ONMF.mshome.net:accounts:8080 - registration status: 204"
 *  Registration Status: 204 => This means that the accounts ms is successfully registered with the Eureka Server. I mean, it tried registering with the Eureka Server, and it got a response '204' from the Eureka Server.
 *  You can also see other kind of information in the logs like: " Starting heartbeat executor: renew interval is: 30" => Which means my Eureka Server by default it's going to expect a heartbeat from the accounts ms every 30 seconds. That's why you can see this log in the logs.
 * - Now, lets go to the Eureka Dashboard and confirm if my accounts ms is registered with the Eureka Server or not. The URL that we need to access here is: http://localhost:8070 which will display the Eureka Dashboard. Now, you should see under the 'Instances currently registered with Eureka' section, there is an application with the name of 'accounts'. So, whatever name that you have defined inside the application.yml file of your accounts ms under the property which is spring.application.name, that's the name that will be displayed inside the Eureka Dashboard for the 'Application' column under the 'Instances currently registered with Eureka' section. So, yea, this is the same name that will be considered and registered with the Eureka Server.
 *   As of now, we only have one instance and that's why you are able to see under the "AMIs' column 1  instance present for the 'accounts' application. And under the 'status' column of this one instance of 'Accounts' ms, you can see 'UP' which means that the instance is alive and well. If you try to click on the green link under this same status column of this one instance of 'Accounts' ms, it will show you more details about this instance of accounts ms. Like what is the app name, description and version . With this visual demo, you should now have complete clarity on how the 'info' related information that we configured in our application.yml file is getting linked and displayed in the Eureka Dashboard. If you check the 'url' of the link that we clicked on, you will see: 'http://172.25.96.1:8080/actuator/info' which is a link against the accounts ms instance it is trying to invoke the path '/actuator/info' at the port 8080.
 *   Also, since we registered our accounts ms using IP address, it is using my local IP address i.e., '172.25.96.1'.
 *   Back to the Eureka Server dashboard under the status column, you can see it is showing some 'hostname' - the green link you clicked on. This is happening because, inside our local  system whenever we install docker and other types of softwares, they are going to make some host entries against the localhost IP address. So, that's why instead of 'localhost' you are seeing something like ' DESKTOP-CR6ONMF.mshome.net:accounts:8080" under the status column of the one instance of accounts ms. So, don't worry about this hostname you are seeing.
 *
 * - Also inside this Eureka Dashboard, we are able to see a RED message like " EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE."
 *   For now, don't worry about this, we are going to discuss this beautiful concept why we are seeing this message later. But for the coming few discussions, please ignore this for now. This is not an error, it is a warning about the Eureka Dashboard and we will see more details about it at a later point in time.
 * - With this, we are able to successfully connect our accounts ms to the Eureka Server and with that, now my accounts ms during the start-up process it registers itself with the Eureka Server and at the same time it is going to send the heartbeats signals to the Eureka Server every 30 seconds.
 * - With this you should be clear about all the changes we have done inside our accounts ms application. The very same set of changes you need to make inside the cards and loans ms's. After that you can your start your individual microservices.
 * - Before trying to start your individual ms's please make sure your config server and eureka servers are up and running. Also after your individual ms's have started, you can go to the Eureka Dashboard just like we did for accounts ms and check if the instances of your individual ms's are registered with the Eureka Server or not. You can also click on the green links under the status column to see more information about the instances of your individual ms's to confirm that they are accurate.
 *  I.e., Like at xxxx port i.e.,8080 port we have deployed accounts ms, and we are able to see the xxx ms i.e.,accounts related information.
 * Up to now you should be clear, We are trying to implement this service discovery and service registration along with the load balancing step by step. The very first step that we need to make sure we have completed is: We should have a separate centralized server which is responsible for storing all the service registry details and act as a service discovery agent. That's why we have built the Eureka server. Post that, we should make sure all our individual ms's are registering there details during the start-up process and also send heartbeat signals to the Eureka Server every 30 seconds. That's why we made the discussed configuration changes inside our individual ms's application.yml files.
 * - Now, lets see an interesting URL of Eureka server i.e., localhost:8070/eureka/apps => If you try to access this you should be able to see all the apps and instances that are registered with the Eureka Server. You should see the below information:
 * +. Under <applications> ...</applications> => You should see several <application> ...</application> tags representing your individual microservices details. For example: <name>ACCOUNTS</name>
 *    Under this ACCOUNTS, you should see instances information, for now we have only one instance registered whose details you can check under <instance>...</instance> tag. If we have multiple instances of ACCOUNTS ms registered then you will be able to see multiple instances information. This we will see visually later. As of now, we are only able to see one instance information. Here your should see details like:
 *    + <instanceId>...</instanceId>
 *    + <hostName>...</hostName>
 *    + <app>...</app> => This is the name of the application that is being registered with Eureka Server.
 *    + <ipAddr>...</ipAddr> => The IP address.
 *    + <status>...</status>
 *    + <port>...</port>
 *    + ....
 * And if you can scroll down, there is also some more information like:
 *    + <leaseInfo>...</leaseInfo> where you can see details like: <renewalIntervalInSecs>...</renewalIntervalInSecs>, what is the registration time - <registrationTimestamp>...</registrationTimestamp>, what is the last renewal timestamp - <lastRenewalTimestamp>...</lastRenewalTimestamp>, what is the service up timestamp - <serviceUpTimestamp>...</serviceUpTimestamp>,...etc
 *  Very similarly you will see information about:
 *    + What is the home page url - <homePageUrl>...</homePageUrl>
 *    + What is the status page url - <statusPageUrl>...</statusPageUrl>
 *    + What is the health check url - <healthCheckUrl>...</healthCheckUrl>
 *    + ... etc
 * This way, we have a lot of information about our individual microservice instances that are registered with the Eureka Server.
 * If you have multiple instances of a microservice/application registered with the Eureka Server, then you will be able to see multiple instances information under the response whenever you try to invoke the url of Eureka server i.e., localhost:8070/eureka/apps.
 * Using this URL only, Anyone can connect with my Eureka server and they can try to get a service registration details. As of now, you can see that by default the response is commming in a XML format. What If I want it in JSON format? The Eureka server supports the JSON format also.
 *  - To get the response in a Json format, copy this URL inside your postman client. Okay, I have already created a collection for this, check the folder with the name 'eurekaserver'. Here you can find a request with the name 'eureka-apps'. Now, before you try to send this request, please make sure you are creating a new header called 'Accept' with the value of 'application/json'. Now, you should be able to see the response in the JSON format. Otherwise by default you will get the response in XML format.
 *    For some reason if you are looking only for 'accounts' related information, then you can use this URL: localhost:8070/eureka/apps/accounts => This will give you the details of the 'accounts' microservice only. The same applies for other ms's as well. Like this you will get a respective ms related information along with the instances' details.
 * Hope you are seeing and realizing the power of Eureka Server which is acting as a discovery agent. We only have 3 microservices here. Think of if we have 100 ms's, how useful this Eurekea Server is going to be per any internal communication between the ms's. For example, where one ms is trying to connect with another ms, then this Eureka Server is going to be a game changer. We are not doing any manual job of updating the IP address details into the registry here. All of these details are getting registered automatically curtesy of a few configurations that we have made in our individual ms's application.yml files during the startup process of the individual ms's.
 * With this consider yourself having successfully create a Eureka Server and registering all your ms's details with it during the startup process of your individual ms's.
 *
 *
 * */
@SpringBootApplication
@EnableEurekaServer
public class EurekaserverApplication {

	public static void main(String[] args) {
		SpringApplication.run(EurekaserverApplication.class, args);
	}

}
