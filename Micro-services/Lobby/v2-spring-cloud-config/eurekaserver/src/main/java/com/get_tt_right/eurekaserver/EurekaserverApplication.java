package com.get_tt_right.eurekaserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

/** Update as of 11/3/2025
 * Generating docker images of our ms's along with the configserver and Eureka Server,then update our docker-compose file and validate the service discovery and registration related changes inside the docker environment as well.
 * ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 * As of now, we have discussed everything around the Eureka Serve. As a next step, lets be generating docker images of our ms's along with the configserver and Eureka Server. Once this is done we can update our docker-compose file and validate the service discovery and registration related changes related changes inside the docker environment as well.
 * For the same:
 * 1. Make sure Docker server is running inside your local system.
 *    B4 starting to generate the docker images, make sure you are adding the jib related plugin details inside the pom.xml of Eureka Server. You can copy this from the pom.xml of the configserver or any other ms as we have done this before and make the necessary adjustments. i.e., Image name  and tag name.
 *    Open the pom.xml file inside Accounts, Cards and Loans ms's and update the tag information from v3 to v4. For configserver, no need to regarding the tag information as everything is upto date, and we didn't make any changes to it.
 *    With this, we can now generate the docker images for all the ms's that we have had changes in. While doing this, always make sure your ms's are stopped. As a next step, go to docker dashboard and make sure to delete images to versions that we are not going to be using i.e., For accounts, cards and loans ms's delete all the images with tag as v3 as we no more need them. But for your reference you can always check with the hub. But no need because every higher version is an improvement over the lower version.
 *    Once this is done, we can now update the docker-compose file and validate the service discovery and registration related changes inside the docker environment as well by using a single docker compose command.
 * Inside the docker-compose folder I am going to open the docker-compose file present inside the default profile.
 * . The instructor removed the RabbitMQ service because he no more needed it. Hel also removed the depends-on.rabbit.condition property under the configserver service because he had removed the RabbitMQ service. He also updated the image tag to the respective services to align with our latest changes.
 * . Copy the configserver service and re-paste it as we want to replicate the eurekaserver service from it. As you know, EurekaServer is going to start at the port 8070 so, update the port mapping to reflect this. After the port mapping, we should also provide the health-check details for the EurekaServer because we want our Accounts, Loans and Cards ms's  to get started only after the configserver, and eurekaserver started successfully. That's why we need to provide the health-check details for the EurekaServer as well.
 * . The command is going to remain the same as it was for the configserver, so we have to just change the port number from 8071 to 8070. The rest other properties related to health, readiness and liveness we already mentioned inside the eurekaserver application.yml file. With this, we should be good from healthcheck perspective. After the healthcheck, you can see we are going to extend the common-config.yml file and the 'service' microservice-base-config.
 * . If you check what is there under the microservice-base-config we have 'deploy' as well as network related instructions. We also have an environment variable which is related to RabbitMQ. The instructor deleted it but I retained everything RabbitMQ because I am still using it. As a next step, I will go to the docker-compose file and there we need to mention a depends-on under the eurekaserver service. Here we are mentioning that our eurekaserver service is going to depend on the configserver since my eurekaserver is going to load its properties with the help of the configserver.
 *   The condition has to be, the configserver service has to be healthy. After this, we should also provide an environment variable under the eurekaserver defining the spring application name details. You can copy it from even accounts service and modify it. Using this same SPRING_APPLICATION_NAME: "eurekaserver" name, we have created a file i.e., eurekaserver.yml inside the configserver.
 *   With this, we should be good as there are no other environment variables that we need to define for my eurekaserver service as it does not depend on any other services or even DB's.
 * . As the next step, I need to find out what other details I need to mention under the accounts, loans and cards services. We know that our individual ms's need to connect with the eureka server and that's why we need to mention an environment variable i.e., . Since it is going to be common for all the ms's, we can mention that inside the common-config.yml file and at the same time all our individual ms's are going to depend on the eurekaserver service. And since this depends-on configuration is common for all the ms's, we can also mention that inder the common-config.yml file.
 *   In the common-config.yml file we have a service with the name microservice-configserver-config. Under this service I am going to add one more depends-on details, just like how e have configserver service. I am going to add 'eurekaserver' as it is the service name that we have create inside the docker-compose file. For this service, we also need to mention the condition as 'service-healthy'. Though I can see we had commented that depends-on related configuration under the microservice-configserver-config service inside common-config.yml and resorted to mentioning this to all the individual services inside the docker-compose file. But yea, lets see what it will lead to.
 *   If it works then well, otherwise you will have to comment this out and mention this depends-on configuration inside the docker-compose.yml file for each of the ms's that are dependent on the eurekaserver service, just like we did earlier for the configserver service. After mentioning this depends-on details under the 'microservice-configserver-config', we can go to the environment variables section just like we have 'SPRING_CONFIG_IMPORT', we should also mention the URL details of the 'eurekaserver' using the property EUREKA_CLIENT_SERVICEURL_DEFAULTZONE. The value of this property is going to be http://eurekaserver:8070/eureka/. This is the default URL of the EurekaServer.
 *   Just after http:// we should not mention 'localhost' instead we should mention the service name that we have mentioned inside the docker-compose.yml file followed by the port number where it will start i.e., 8070 and after the prot we need to mention /eureka/
 * . With these updates, all the configurations that we have updated under the service name 'microservice-configserver-config' will now be utilized by acconts, laons and cards ms's
 *   With these changes we should be good, I can try to copy the same docker-compose.yml file as well as the common-config.yml file into other profiles like qa and prod. The only difference between these files in the various envrionments i.e., default, qa and prod is the property value of the environment variable SPRING_PROFILES_ACTIVE: xxx. You may be wondering why I am trying to duplicate the same common-config.yml and docker-compose.yml files inside the default prod as well as qa folders! haha Like we discussed, this will give you flexibility in future whenever you want to go with different requirements in different environments, then you can easily update the respective .yml files present in the docker-compose folder.
 *   With this, we are now good to go. next is trying to start all the containers with the help of docker compose up command and try to validate the Eureka Changes that we have developed inside the docker environment. Lets tests with the default profile. So navigate into docker-compose/default where we have a docker-compose.yml file which is specific to the default environment. From this location, run the command docker compose up -d Before trying to execute this command please make sure you don't have any other running/stopped containers so that you are giving enough memory to the docker compose up -d command.
 * . You can see that my configserver ms only is trying to start, until its health is good, no other ms container is going to start. Once it is healthy then my eurekaserver ms will try to start. We waited for few minutes and eventually eureka server failed to start.
 *   To try to understand why? Inside my containers, click on eurekaserver-ms, you will notice that it seems that it is not able to connect with my configserver  and that's why you are seeing exceptions like: 'Connection Refused'.  Inside my docker-compose.yml file, for eurekaserver, we are extending the service which is 'microservice-base-config' and whenever we are using microservice-base-config, we are only going to get the network related configurations and the deployment related configurations. So do you think it is valid to use it as an extention inside the eurekaserver service inside the docker-compose.yml file? Of course, we can't use this like that because it has one more extra environment variable configuration which is the 'EUREKA_CLIENT_SERVICEURL_DEFAULTZONE' which is not required for the EurekaServer service to start.
 *   That's why I am going to cut the environment variable like SPRING_CONFIG_IMPORT and SPRING_PROFILES_ACTIVE other than the EUREKA_CLIENT_SERVICEURL_DEFAULTZONE and mention the same under the docker-compose file for the eurekaserver service. But instead of doing all this, we can try to create one more service inside the common-config.yml file which is going to have the eureka specific details i.e., microservice-eureka-config and this is going to extends 'microservice-configserver-config'. Just copy microservice-configserver-config and replicate microservice-eureka-config from it.
 *   - In the environment variables remove SPRING_PROFILES_ACTIVE, SPRING_CONFIG_IMPORT, SPRING_DATASOURCE_USERNAME and SPRING_DATASOURCE_PASSWORD since those are already present in the top service i.e., microservice-configserver-config. Make sure to extend microservice-configserver-config to microservice-eureka-config. Up to now, you can see that microservice-eureka-config is going to simply have the details related to eurekaserver and and the dependency on the eureka serever. Now from the microservice-configserver-config, I am going to delete the dependency details of 'eurekaserver'  i.e., depends-on.eurekaserver.condition  and under the environment variables I am going to delete the eurekaserver client related information i.e., EUREKA_CLIENT_SERVICEURL_DEFAULTZONE because this information we have under the 'microservice-eureka-config' service.
 * . With these adjustments inside the common-config.yml file, we need to go inside the docker-compose.yml file  and under the accounts service, we instead need to extend microservice-eureka-config instead of microservice-configserver-config. Do the same for loans as well as accounts ms's. For the eurekaserver service, extend the 'microservice-base-config'  instead of 'microservice-base-config'. Up to now, under the service 'eurekaserver' we don't need to mention 'depends_on' configurations since  this is already present inside the common-config.yml file under the 'microservice-configserver-config', but remember I commented it out and maintained it inside the docker-compose file under the 'eurekaserver' service. Uncomment and comment respectively. If you face any issue, then just maintain the depends-on configuration(s) inside the respective service(s) inside the docker-compose file instead of the common-config.yml file.
 *   With this I assume we should be good in terms the eurekaserver service definition inside the docker-compose.yml file. Now, save the changes and try to run the docker compose up command again. Before that, make sure to run the docker compose down command to remove any running and stopped containers. Fingers crossed, run the docker compose up command again. This time again, unfortunately the docker compose up -d command didn't start my eureka service! heeeh! Let's again try to check what the issue could be! In my common-config.yml for the service 'microservice-configserver-config' I had mentioned the child elements to the 'environment' variable without a tab space. You see why you need to be very crisp careful! Just because I missed the tab space, my eurekaserver is unable to connect with the configserver. With this, lets hope our docker-compose.yml file is going to work!
 *   This time my eurekaserver started successfully and that's why you can see that my other ms's are trying to get started. You can validate the same inside the docker dashboard. If you check the eurekaserver logs, you can see that it started successfully. The same has just happened for all the other ms's as well. Hurreey!!
 * . Meanwhile, you can try accessing the Eureka dashboard at the path: locolhost:8070 and yeey! you can see that all our ms instances started successfully and registered themselves with the eurekaserver. As a next step, you can go to postman and try to test the API's. Do the CREATE requests for cards, loans as well as the Accounts ms's. Make sure the mobile number is the same across.
 *   The next request that we need to test is FetchCustomerDetails. Behind the scenes, when we try to invoke this API, the feign client will leverage the eureka server and try to invoke other ms's like loans and cards. Yeey! We got a successful response just as expected! With this our Eureka related changes are working in the docker environment as well. So, copy the docker-compose.yml file and common-config.yml file related contents and replicate them inside the prod and qa folders of docker-compose folder. Make sure to change the SPRING_PROFILES_ACTIVE property value to reflect the correct environment.
 *   With this, all the docker-compose files that we have inside the default, prod and qa should work without any issues. You can always test that by yourself. After you are completed with your verifications, make sure to always do the docker compose down so that you can delete any running and stopped containers to free up some space and memory on your PC.

 * */
@SpringBootApplication
@EnableEurekaServer
public class EurekaserverApplication {

	public static void main(String[] args) {
		SpringApplication.run(EurekaserverApplication.class, args);
	}

}
