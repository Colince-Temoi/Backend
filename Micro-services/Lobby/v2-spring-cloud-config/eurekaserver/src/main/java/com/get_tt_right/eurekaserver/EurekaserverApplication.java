package com.get_tt_right.eurekaserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

/** Update as of 4/3/2025
 * As of now, we have seen a demo that our individual ms's are able to connect with the Eureka Server during the startup and register themselves. That's why we are able to see the details of our ms's in the Eureka Server Dashboard. In this session, we are going to see a demo on how our ms's are going to de-register themselves from the Eureka Server during the shutdown process. To see this, we should not shut down our applications/ms's using the Intellij IDE.
 *  Yes we have an option to do that from the Intellij IDE, but it will not be a graceful shutdown. Reason: This is going to kill your applications instantly and usually we will not follow this approach inside higher environments like qa and production. We are going to shut down our applications/ms's gracefully using some scripts or by using the shutdown path available inside the actuator. Previously we added some shut down related configurations inside our application.yml files of the respective ms's.
 *  If you can check the property: endpoints.shutdown.enabled=true => It will enable the shutdown related endpoints. At the same time we also mentioned the property management.endpoint.shutdown.enabled=true. With these properties now, there will be a shut-down endpoint exposed inside the actuator of your application. To know more details about the shutdown API path available inside the actuator, I am going to invoke localhost:8080/actuator/shutdown. This is the shutdown actuator url available inside my accounts application.
 *  If you invoke this url in your browser, your will get a 405 'Method Not Allowed'.  In your postman collection, you will find a request for each of your ms's named: ShutDown. On invoking it, this way we are going to shut down our applications/ms's gracefully. The shutdown process is not going to be immediate, it is going to take some grace period and make sure it is performing some tasks before shutting down. One of those tasks is going to be to de-register our ms's  details from the Eureka Server. On making this request you will get a response saying that "Shutting down, bye..."
 *  If you go to the Eureka dashboard and refresh the page, you will see that our accounts ms details are not present anymore. This means, my accounts ms during the shutdown process has de-registered itself from the Eureka Server and with that, there won't be any details about accounts ms inside the service registry, that is maintained by the Eureka Server. Inside the logs we can also see this, if you open the logs related to accounts ms, you will see message logs  like this: "Commencing graceful shutdown. Waiting for active requests to complete", there is also a log related to "Unregistering ...", Also you can see a log like, so-and-so ms is de registered and the status from the Eureka Server is 200. i.e., "DiscoveryClient_ACCOUNTS/DESKTOP-CR6ONMF.mshome.net:accounts:8080 - deregister  status: 200"
 *    This confirms that all the details about this accounts ms instance are removed from the service registry. You can confirm the same by visualizing with the cards and loans ms's also just the same way as we have discussed above.
 * - Now, if you go back to the Eureka Dashboard and refresh the page, you will see that under the section "Instances currently registered with Eureka", there are no ms instances present anymore. This means that all the ms instances are de-registered from the Eureka Server/Service Registry. If there are no details inside the service registry, then there is no concept of service discovery anymore.
 *  From our discussion above, it can be confirmed that the behavior of all our ms's that if they get shut down gracefully, they will de-register themselves from the Eureka Server. This way, the registration process and un-registration process is happening automatically during the startup and shutdown process of the respective ms's. Next, we are going to visually see the heartbeat behavior, I mean how the heartbeats are going to be send to the Eureka Server from our individual ms's.
 *
 * Heartbeat Mechanism visual discussion
 * --------------------------------------
 * - We will see demo of the heartbeats that will be sent by the ms's to the Eureka Server. We will do a demo with Accounts ms, so make sure it is started. By the time they are starting successfully, behind the scenes they will also register there instance details with the Eureka Server. This you can validate from the logs i.e., "DiscoveryClient_ACCOUNTS/DESKTOP-CR6ONMF.mshome.net:accounts:8080 - registration status: 204"  or by going to the Eureka dashboard under the section "Instances currently registered with Eureka". To show you that ms's will always attempt to send a heartbeat every 30 seconds which is the default heartbeat interval, I am going to shut down the Eureka Server. Before shutting down the Eureka Server first clean the console logs of Accounts/Cards/Loans ms. Post that, stop the Eureka Server.
 *   With that,after some time, we will be able to see some exceptions inside the logs of our ms's that they are trying to send the heartbeats but Eureka Server is not responding. If you try to understand these Execution, there will be details related to heartbeat. Maybe what you can do is search for a word,"Heartbeat" - There are so many matches for this search string, but if you search through, you will see something like, "...was unable to send heartbeat!". In the logs, the line just above this message i.e., "Request execution failed with message: I/O error on GET request for "http://localhost:8070/eureka/apps/delta": Connect to http://localhost:8070 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: getsockopt" you can see that Accounts ms is trying to send a request of type PUT to so-and-so url of Eureka Server to update the heartbeat details but since the Eureka server itself is down that's why we are seeing these kinds of exceptions inside the console logs of Accounts ms.
 *   The same thing is also happening for Cards and Loans ms's. They are also trying to send the heartbeats to the Eureka Server but since the Eureka Server is down, they are not able to send the heartbeats, and they are getting exceptions inside the console logs as discussed above.
 * - This confirms that our individual ms's are trying to send the heartbeat signals to the Eureka Server. With this, it should be clear for you that during the startup registration with the Eureka Server will be taken care if by the Individual Ms's and once the services are started successfully, even the heartbeat signals will be send every 30 seconds to the Eureka Server to make sure that Eureka Server is maintaining only the instance details which are running and healthy. At last, during the shutdown process of our individual ms's, they are going to de-register themselves from the Eureka Server. All these are happening automatically. Nowhere we are doing this manually, the communication between ms's and Eureka Server is happening automatically. Now, you can consider the setup of Eureka Server as a Service Discovery Agent as a complete setup. At the same time our ms's are also communicating with the Eureka Server to register themselves during the startup process, send the heartbeat signals after every 30 seconds to tell the Eureka Server that they are healthy and running and de-register themselves from the Eureka Server during the shutdown process.
 *   As a next step, we need to understand how a ms can rely on this Eureka Server to discover other service details and in the same process how it is going to perform the load balancing of the requests.
 *
 *   Understanding how a ms can rely on this Eureka Server to discover other service details and in the same process how it is going to perform the load balancing of the requests
 *   -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 * - We now want to explore about service discovery and how the client side load balancing is going to work whenever we are using Eureka server inside our ms's network. To show a demo about this concept, we are going to build a new REST API inside the Accounts ms. The responsibility of this new REST API will be - To accumulate Accounts,Loans & Cards related information based on a given mobile number and it should consolidate all the responses from all the other microservices like Accounts, Cards & Loans such that all the data of a given customer it has to respond back to the client whoever is invoking these new REST API.
 *   As of now, we have a scenario where my accounts ms does not have any information related to cards and loans so, it has to connect with the cards and loans ms's to get the data and that's how we are going to have a scenario where Accounts ms is trying to communicate with other ms's like Cards and Loans ms's internally inside our ms network. To establish the internal communication between the ms's like we discussed earlier on in our theoretical sessions we will leverage a client library i.e., OpenFeign library. Before we try to implement thos changes, first make sure all the running instances inside your local system are stopped.
 * - Under the spring.start.io, get a dependency "openfeign". This is a starter project. Add this dependency to your Accounts pom.xml file. On loading the maven changes, with this we should have all the openfeign related libraries downloaded and ready to use inside the Accounts ms. Now, go to the Spring Boot main class inside the Accounts ms and add an annotation with the name of @EnableFeignClients. This will enable the feign client support inside the ms and with that, my Accounts ms can connect with other ms's like Cards and Loans ms's. In the traditional approach, in order to connect with Loans and Cards ms's, in the traditional approach we would use some RestTemplate or WebClient
 *   and to those clients or interfaces were are to pass what is the URL, Request data, Port Number, What is the Exception handling, ...etc. This means that we need to write all the actual logic to invoke the loans and cards ms's. But whenever we are using OpenFeign client, we don't have to stress ourselves this much. We just have to write the declarative code. This kind of approach we are already following inside the Spring data Jpa. Suppose, if you go to the repository package of this Accounts ms, you will see an interface like: AccountsRepository. Did we write any implementation logic here to fetch the records based upon the customer id? No, we have written only the declarative code i.e., Optional<Accounts> findByCustomerId(Long customerId);
 *   Which means, I only created an interface along with abstract methods and behind the scenes my Spring data JPA framework is going to generate the implementation code for me at runtime. Very similarly, whenever we are using OpenFeign client we don't have to write any implementation code/the actual logic. We just have to create the interfaces along with the abstract methods and behind the scenes my OpenFeign framework is going to generate the implementation code at runtime.  Now under the services package, I am going to create another package with the name 'client'. Under this package, I am going to create a new interface with the name CardsFeignClient because this interface is going to help my Accounts ms to connect with the cards ms.
 * - To use the OpenFeign libraries, we need to make sure we are mentioning on top of CardsFeignClient interface an annotation i.e., @FeignClient(-). As an input, we need to mention a value which is 'cards', because using this same value we have used to register with the Eureka Server. If you recall, inside the Eureka dashboard all the cards related instances will register with a logical name, 'cards' . This same logical name, we need to mention as an input value to @OpenFeign(-) so that my feign client will connect with the Eureka Server at runtime, and it will try to get all the cards ms instances with a logical name 'cards'. That's the main purpose of this @FeignClient(-) annotation and the logical name that we are passing as an input value.
 * # Check the CardsFeignClient for a more detailed discussion.
 * */
@SpringBootApplication
@EnableEurekaServer
public class EurekaserverApplication {

	public static void main(String[] args) {
		SpringApplication.run(EurekaserverApplication.class, args);
	}

}
